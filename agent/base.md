# リファクタリング演習問題 作成ガイド

## 対象者

Java経験者（Java Gold保持）でTypeScript初心者向けの演習問題を作成する

## ディレクトリ構成

```
XX-domain-name/
├── 問題.ts       (100-250行、ヒントコメントなし)
├── ヒント.md     (問題点とアプローチを説明)
└── 回答例.md     (完全なコードと解説)
```

**命名ルール**: 答えを明かさない業務ドメイン名を使用
- ✅ `01-order-system/`
- ❌ `01-magic-numbers/`

## 問題.ts の書き方
- ヒントコメントは一切入れない
- 実務で見られそうなコード
- 100-250行程度
- コンパイル可能なコード

```typescript
/**
 * 簡単な業務説明のみ
 */

interface Order { ... }

class OrderService {
  // アンチパターンが含まれるコード
}
```

## ヒント.md の構成

```markdown
# ヒント

## 問題点
このコードには「XXX」というアンチパターンが含まれています。

### 具体的な問題
1. 問題1の説明
2. 問題2の説明

## リファクタリングのアプローチ
### 1. 手法1
簡単なコード例

### 2. 手法2
より良いコード例

## 参考キーワード
- キーワード1
- キーワード2
```

## 回答例.md の構成

```markdown


```markdown
# 回答例

## リファクタリング後のコード
完全な動作するコード（長くなってもOK）

## 改善ポイント
- 何をどう改善したか
- なぜその設計にしたか

## メリット
- テスタビリティ/可読性/保守性の向上
```

## 重点アンチパターン

1. マジックナンバー/文字列
2. 密結合（DI不足）
3. コード重複（DRY違反）
4. 神関数（100行以上）
5. 深いネスト（10階層以上）
6. 参照共有による副作用
7. エラーハンドリング不足
8. 型安全性の欠如（any濫用）

## 作成時のチェック

- [ ] 問題.tsにヒントコメントなし
- [ ] ディレクトリ名が答えを明かしていない
- [ ] ヒント.mdでアンチパターン名を明示
- [ ] 回答例.mdに完全なコードがある
- [ ] exercises/README.mdに問題を追加

## exercises/README.md の更新

新しい問題を追加したら、必ず`exercises/README.md`の問題一覧を更新してください。

### 追加する場所

難易度に応じて適切なセクションに追加：

- ⭐️⭐️ まずはここから！
- ⭐️⭐️⭐️ 慣れてきたらこのあたり
- ⭐️⭐️⭐️⭐️ ちょっと難しめ
- ⭐️⭐️⭐️⭐️⭐️ 上級者向け

### 記載形式

```markdown
| **XX. 問題名** | 簡単な内容説明（1行） |
```

**重要**: 「学べること」は記載しない（答えを明かさないため）
```

### 重要なポイント

1. **完全なコードを提供**
   - 動作する完全なリファクタリング後のコード
   - 型定義も完全に記述
   - ファイルが長くなっても良い（1000行以上でも可）

2. **複数のアプローチを示す**
   - 基本的なリファクタリング版
   - より高度なパターン適用版（オプション）
   - 段階的に理解できるように構成

3. **なぜその設計にしたのか説明**
   - Before/Afterの比較
   - 各改善がもたらすメリット
   - 実務での適用場面

4. **テストコード例も含める（可能なら）**
   - リファクタリング後のコードのテスト例
   - テストしやすくなったことを示す

## アンチパターンの選定基準

### 優先度の高いアンチパターン

1. **マジックナンバー・マジックストリング**
   - 実務で頻繁に見られる
   - 初心者でも理解しやすい

2. **密結合・依存性の問題**
   - Java経験者には理解しやすい（DIの概念）
   - 実務で重要

3. **コードの重複（DRY原則違反）**
   - 誰でも理解できる
   - リファクタリングの効果が明確

4. **巨大な関数（神関数）**
   - 100行以上の関数
   - 複数の責務を持つ
   - 実務でよく見られる

5. **極端に深いネスト（10階層以上）**
   - 可読性の問題を実感しやすい
   - ガード句などの技法を学べる

6. **オブジェクトの参照共有による意図しない副作用**
   - JavaScriptの基礎である参照型の理解に重要
   - 初心者がよくハマるバグパターン
   - ループ内での共有オブジェクト使用など
   - シャローコピー・ディープコピーの理解

7. **エラーハンドリングの問題**
   - 実務で重要
   - try-catchの適切な使用

8. **型安全性の欠如**
   - TypeScriptならではの問題
   - `any`の濫用など

### 問題の規模の目安

| 難易度 | 行数      | 複雑さ                                     |
| ------ | --------- | ------------------------------------------ |
| ⭐️⭐️☆☆☆  | 50-100行  | 1-2個の明確なアンチパターン                |
| ⭐️⭐️⭐️☆☆  | 100-150行 | 2-3個のアンチパターン、関数分割が必要      |
| ⭐️⭐️⭐️⭐️☆  | 150-250行 | 複数の設計パターンが必要、クラス分割が必要 |
| ⭐️⭐️⭐️⭐️⭐️  | 200行以上 | 高度な型システム、DDD的な設計が必要        |

## 品質チェックリスト

演習問題を作成したら、以下を確認してください：

### 問題.ts

- [ ] ヒントコメントが含まれていない
- [ ] コンパイルエラーがない（意図的な場合を除く）
- [ ] 実務で実際にありそうなコード
- [ ] ビジネスドメインが明確
- [ ] 適切な規模（100-250行程度）

### ヒント.md

- [ ] アンチパターン名が明示されている
- [ ] 問題点が3-5個リストアップされている
- [ ] 複数のリファクタリングアプローチが示されている
- [ ] 考えさせる質問が含まれている
- [ ] 参考キーワードが提供されている

### 回答例.md

- [ ] 完全なリファクタリング後のコードがある
- [ ] Before/Afterの比較説明がある
- [ ] リファクタリングの各ポイントが説明されている
- [ ] メリットが具体的に説明されている
- [ ] まとめがある

### ディレクトリ構成

- [ ] ディレクトリ名が答えを明かしていない
- [ ] 業務ドメイン名を使用している
- [ ] 番号が適切（2桁、欠番利用可）

## README.md の更新

問題を追加したら、必ずREADME.mdを更新してください。

### 記載内容

```markdown
### XX. 問題のタイトル（業務ドメイン名）

**難易度**: ⭐️⭐️⭐️☆☆

簡単な説明（1-2行）

- **学べること**:
  - 学習項目1
  - 学習項目2
  - 学習項目3

📁 [`XX-directory-name/`](./XX-directory-name/)
```

## 実装例

### 良い問題の例

**ディレクトリ名**: `03-order-service/`

**問題.ts**: 150行の注文処理コード（神関数）
- ヒントコメント一切なし
- バリデーション、ビジネスロジック、永続化が全て1関数に
- 実際の注文システムを模した内容

**ヒント.md**:
- 「巨大な関数（神関数）」と明示
- 5つの問題点を指摘
- バリデーター分離、サービス層分離など複数のアプローチ
- 「いくつの関数に分割すべきか？」などの質問

**回答例.md**:
- 10個のクラスに分割した完全なコード（1000行以上）
- 各分割のポイント説明
- ストラテジーパターン版も提供（応用編）
- テストコード例も含む

### 悪い問題の例

❌ **ディレクトリ名**: `01-magic-numbers/`
→ 答えが分かってしまう

❌ **問題.ts**:
```typescript
// 問題: マジックナンバーの使用
const price = amount * 1.1; // ← これがヒント
```
→ コメントで答えを教えてしまっている

❌ **ヒント.md**:
```markdown
# ヒント

マジックナンバーは使わないでください。
```
→ 説明が不十分、アプローチが示されていない

❌ **回答例.md**:
```markdown
# 回答例

定数を使ってください。

```typescript
const TAX_RATE = 1.1;
```
→ コードが断片的、説明が不足

## まとめ

このガイドラインの核心:

1. **答えを与えすぎない** - 受講者が自分で発見する
2. **実践的な例** - 実務で本当に見られるコード
3. **段階的な学習** - ヒント → 実装 → 回答例の順
4. **複数のアプローチ** - 1つの正解に縛らない
5. **完全な回答例** - 中途半端にしない、動作するコードを提供

これらの原則に従うことで、受講者の学習効果を最大化できます。