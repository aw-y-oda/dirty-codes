/**
 * やりがちなアンチパターン集
 *
 * このファイルは、開発でよく見られる問題のあるコードパターンと
 * その改善方法をまとめたものです。
 */

/**
 * 1. マジックナンバーの使用
 * - 問題: 意味の分からない数値がコード内に直接書かれている。
 * - 例: if (status === 2) { ... }
 * - 改善: 意味のある定数を使用する。
 *   const STATUS_APPROVED = 2;
 *   if (status === STATUS_APPROVED) { ... }
 */

/**
 * 2. 密結合
 * - 問題: モジュールやクラスが他のモジュールやクラスに強く依存している。
 * - 例: クラスAがクラスBの具体的な実装に依存している。
 * - 改善: インターフェースや依存性注入を使用する。
 */

/**
 * 3. 悪いネーミング
 * - 問題: 変数や関数の名前が意味を持たない。
 * - 例: let x = 10; function doStuff() { ... }
 * - 改善: 名前に意図を込める。
 *   let userAge = 10; function calculateTotal() { ... }
 */

/**
 * 4. 冗長なコード（コードの重複）
 * - 問題: 同じコードが複数箇所にコピー＆ペーストされている。
 * - 例: 複数の関数で同じロジックを繰り返している。
 * - 改善: 共通のロジックを関数やモジュールに切り出す。
 */

/**
 * 5. エラーハンドリングの欠如
 * - 問題: エラーが発生しても適切に処理されない。
 * - 例: try-catchを使用していない、またはcatchブロックが空。
 * - 改善: エラーを適切にログに記録し、必要に応じて再スローする。
 */

/**
 * 6. コメントの欠如または過剰
 * - 問題: コメントが全くない、またはコードをそのまま説明する無意味なコメント。
 * - 例: // xを10に設定する let x = 10;
 * - 改善: なぜそのコードが必要なのかを説明するコメントを書く。
 */

/**
 * 7. 過剰なネスト
 * - 問題: 条件分岐やループが深くネストしている。
 * - 例: if (a) { if (b) { if (c) { ... } } }
 * - 改善: 早期リターンや関数分割を使用してネストを浅くする。
 */

/**
 * 8. 無意味なラップ関数
 * - 問題: ただの関数呼び出しをラップしているだけで、何の意味もない。
 * - 例: function getUserName(user) { return user.name; }
 * - 改善: 意味のある抽象化をする。不要なら直接使う。
 */

/**
 * 9. 配列 or オブジェクトの手動初期化地獄
 * - 問題: 同じような初期化コードを何十行も手書きしている。
 * - 例: obj.a = 1; obj.b = 2; obj.c = 3; ...
 * - 改善: ループやマッピングを使う。構造化されたデータで管理。
 */

/**
 * 10. 変数名に型情報を入れがち
 * - 問題: strUserName, intUserAge など、型が名前に入っている。
 * - 改善: 型は型システムに任せる。名前は意味に集中する。
 */

/**
 * 11. コメントでコードを無効化して放置
 * - 問題: // return false; のようなコメントアウトされたコードが残っている。
 * - 改善: Gitで履歴管理されているので、不要なら削除する。
 */

/**
 * 12. 使われてない変数を残す
 * - 問題: let unused = 0; のような使われてない変数が放置されている。
 * - 改善: Lintで検出、削除する。コードの意図を明確に。
 */

/**
 * 13. すべての処理を1つの関数に詰め込む
 * - 問題: 100行以上の巨大関数が存在する。
 * - 改善: 処理を分割して、関数ごとに責務を明確にする。
 */

/**
 * 14. 変数名が略語すぎて意味不明
 * - 問題: let u = getU(); など、略語が多すぎて何をしているか分からない。
 * - 改善: user, unit, url など、略さずに書く。
 */

/**
 * 15. 条件分岐が多すぎて読めない
 * - 問題: if (a && b || (!c && d)) { ... } のような複雑な条件式。
 * - 改善: 条件を変数に分けて意味を明確にする。
 */

/**
 * 16. 例外を握りつぶす
 * - 問題: catch (e) {} のように何もせずに例外を無視。
 * - 改善: ログに残す、再スローする、ユーザーに通知するなど適切に処理。
 */

/**
 * 17. すべての値をグローバルに置く
 * - 問題: window.config = {...} のようにグローバルに値を置いてしまう。
 * - 改善: スコープを限定し、モジュール化する。
 */

/**
 * 18. 変数の再利用でバグを生む
 * - 問題: let result = ...; result = ...; のように同じ変数名を使い回す。
 * - 改善: 変数は目的ごとに分けて、再利用しない。
 */

/**
 * 19. 何でもとりあえず any にする（TypeScript）
 * - 問題: 型が分からないからとりあえず any にしてしまう。
 * - 改善: 型を明示するか、推論に任せる。unknown や Record<string, unknown> なども検討。
 */

/**
 * 20. console.log をデバッグに使いすぎる
 * - 問題: console.log("ここまで来た") などが大量に残っている。
 * - 改善: デバッガやロガーを使う。不要なログは削除。
 */

/**
 * 21. TODOコメントが放置されている
 * - 問題: // TODO: 後で直す が何ヶ月も放置されている。
 * - 改善: チケット化する、期限を決める、レビューで確認する。
 */

/**
 * 22. true / false を直接返すだけの関数
 * - 問題: function isValid() { return true; }
 * - 改善: 意味のある条件を実装する。仮実装ならコメントで明示。
 */

/**
 * 23. switch文が巨大すぎる
 * - 問題: switch (type) が100ケース以上ある。
 * - 改善: 処理を関数に分ける。マッピングオブジェクトを使う。
 */

/**
 * 24. nullとundefinedの違いを理解してない
 * - 問題: if (value == null) で両方を曖昧に扱う。
 * - 改善: 明確に使い分ける。型で制約をかける。
 */

/**
 * 25. setTimeoutで非同期処理を雑に扱う
 * - 問題: setTimeout(() => doSomething(), 1000); で非同期を制御しようとする。
 * - 改善: Promiseやasync/awaitを使う。
 */

/**
 * 26. 汎用的な型を異なる概念で共有してしまう
 * - 問題: id, name のような汎用的な項目を持つ異なる概念のデータに、
 *         IdAndName のような共通の型を使ってしまう。
 * - 例: type IdAndName = { id: string; name: string };
 *       const user: IdAndName = { id: "1", name: "太郎" };
 *       const product: IdAndName = { id: "1", name: "商品A" };
 * - 改善: 違う概念のものは個別に型を作る。
 *         たまたま型が似ているからといって同じ型にまとめない。
 *   type User = { id: string; name: string };
 *   type Product = { id: string; name: string };
 */

/**
 * 27. ファイルに複数責務が詰まっているせいで変数名が長くなる
 * - 問題: 1ファイルに複数責務が詰まっているせいで、IDのように単純な変数名でいいはずなのに
 *         userProfileId, productOrderId のように長い名前になってしまう。
 * - 改善: ファイルを分割して責務を分ける。
 *         責務ごとにファイルを分けることで、シンプルな変数名が使える。
 */

/**
 * 28. 巨大な関数（神関数）
 * - 問題: 1つの関数が100行を超え、複数の責務を持っている。
 *         バリデーション、ビジネスロジック、データ保存、通知など全てが1つの関数に。
 * - 例: processOrder関数が200行以上あり、入力検証から注文保存、在庫更新、
 *       メール送信まで全て行っている。
 * - 改善: 関数を責務ごとに分割する。
 *   - validateOrderRequest()
 *   - calculateOrderAmount()
 *   - saveOrder()
 *   - updateInventory()
 *   - sendNotification()
 */

/**
 * 29. 極端に深いネスト（10階層以上）
 * - 問題: if文やループが10階層以上ネストしており、コードの流れが追えない。
 *         同じロジックが何度も繰り返される。
 * - 例: if (a) { if (b) { if (c) { if (d) { if (e) { if (f) { ... } } } } } }
 * - 改善: 早期リターン、関数分割、ポリモーフィズム、戦略パターンなどを使用。
 *   - ガード節で異常系を先に処理
 *   - 計算ロジックを別関数に抽出
 *   - マッピングオブジェクトで条件分岐を置き換え
 */

/**
 * 30. オブジェクトの参照共有による意図しない副作用
 * - 問題: オブジェクトの参照をコピーしたつもりで、実際には同じオブジェクトを指している。
 *         ループ内で同じオブジェクトを使い回すため、意図しない上書きが発生する。
 * - 例: const obj = { value: 0 };
 *       const copy = obj; // これは参照のコピー（同じオブジェクト）
 *       copy.value = 1;
 *       console.log(obj.value); // 1 になってしまう
 *
 *       for (let i = 0; i < items.length; i++) {
 *         const result = baseObject; // 毎回同じオブジェクトを参照
 *         result.value = items[i];    // 上書きされていく
 *         list.push(result);          // 全て同じオブジェクトへの参照
 *       }
 * - 改善: オブジェクトを明示的にコピーする。または新しいインスタンスを作成する。
 *   - const copy = { ...obj }; // スプレッド構文でシャローコピー
 *   - const copy = Object.assign({}, obj); // Object.assignでコピー
 *   - const copy = structuredClone(obj); // ディープコピー（新しいAPI）
 *   - const result = new ClassName(); // 毎回新しいインスタンスを作成
 *   - const result = factory.create(); // ファクトリーメソッドで作成
 */
