# 回答例: 密結合

## リファクタリング後のコード

```typescript
/**
 * 通知チャネルのインターフェース
 */
interface NotificationChannel {
  send(recipient: string, message: string): Promise<void>;
  getChannelName(): string;
}

/**
 * ユーザーリポジトリのインターフェース
 */
interface UserRepository {
  getEmail(userId: string): Promise<string>;
  getPhoneNumber(userId: string): Promise<string>;
}

/**
 * メール通知チャネル
 */
class EmailChannel implements NotificationChannel {
  async send(recipient: string, message: string): Promise<void> {
    console.log(`Sending email to ${recipient}`);
    console.log(`Subject: Notification`);
    console.log(`Body: ${message}`);
    // 実際のメール送信処理
  }
  
  getChannelName(): string {
    return 'email';
  }
}

/**
 * SMS通知チャネル
 */
class SMSChannel implements NotificationChannel {
  async send(recipient: string, message: string): Promise<void> {
    console.log(`Sending SMS to ${recipient}`);
    console.log(`Message: ${message}`);
    // 実際のSMS送信処理
  }
  
  getChannelName(): string {
    return 'sms';
  }
}

/**
 * Push通知チャネル（新しい通知方法を簡単に追加できる）
 */
class PushChannel implements NotificationChannel {
  async send(recipient: string, message: string): Promise<void> {
    console.log(`Sending push notification to ${recipient}`);
    console.log(`Message: ${message}`);
    // 実際のPush通知送信処理
  }
  
  getChannelName(): string {
    return 'push';
  }
}

/**
 * ユーザーリポジトリの実装
 */
class UserRepositoryImpl implements UserRepository {
  async getEmail(userId: string): Promise<string> {
    // 実際にはデータベースから取得
    return `user${userId}@example.com`;
  }
  
  async getPhoneNumber(userId: string): Promise<string> {
    // 実際にはデータベースから取得
    return `090-1234-${userId}`;
  }
}

/**
 * 通知設定
 */
interface NotificationConfig {
  channels: NotificationChannel[];
  userRepository: UserRepository;
}

/**
 * 通知サービス（疎結合版）
 */
class NotificationService {
  private channels: Map<string, NotificationChannel>;
  private userRepository: UserRepository;
  
  constructor(config: NotificationConfig) {
    this.channels = new Map();
    config.channels.forEach(channel => {
      this.channels.set(channel.getChannelName(), channel);
    });
    this.userRepository = config.userRepository;
  }
  
  /**
   * 指定されたチャネルでユーザーに通知を送信
   */
  async notifyUser(
    userId: string,
    message: string,
    channelNames: string[]
  ): Promise<void> {
    const notificationTasks: Promise<void>[] = [];
    
    for (const channelName of channelNames) {
      const channel = this.channels.get(channelName);
      
      if (!channel) {
        console.warn(`Channel ${channelName} not found`);
        continue;
      }
      
      const recipient = await this.getRecipient(userId, channelName);
      notificationTasks.push(channel.send(recipient, message));
    }
    
    await Promise.all(notificationTasks);
  }
  
  /**
   * チャネルに応じた宛先を取得
   */
  private async getRecipient(userId: string, channelName: string): Promise<string> {
    switch (channelName) {
      case 'email':
        return this.userRepository.getEmail(userId);
      case 'sms':
      case 'push':
        return this.userRepository.getPhoneNumber(userId);
      default:
        return userId;
    }
  }
}

/**
 * 注文サービス（疎結合版）
 */
class OrderService {
  private notificationService: NotificationService;
  
  /**
   * 依存性注入により、NotificationServiceを外部から受け取る
   */
  constructor(notificationService: NotificationService) {
    this.notificationService = notificationService;
  }
  
  async createOrder(userId: string, productId: string): Promise<void> {
    console.log(`Creating order for user ${userId}`);
    
    // 注文処理
    
    // 通知を送信（メールのみ）
    await this.notificationService.notifyUser(
      userId,
      'Your order has been placed successfully!',
      ['email']
    );
  }
  
  async cancelOrder(userId: string, orderId: string): Promise<void> {
    console.log(`Cancelling order ${orderId}`);
    
    // キャンセル処理
    
    // 通知を送信（メールとSMSの両方）
    await this.notificationService.notifyUser(
      userId,
      'Your order has been cancelled.',
      ['email', 'sms']
    );
  }
}

// 使用例: DIコンテナのような役割を果たすセットアップ
function createOrderService(): OrderService {
  // 依存関係を構築
  const userRepository = new UserRepositoryImpl();
  const emailChannel = new EmailChannel();
  const smsChannel = new SMSChannel();
  const pushChannel = new PushChannel();
  
  const notificationService = new NotificationService({
    channels: [emailChannel, smsChannel, pushChannel],
    userRepository,
  });
  
  return new OrderService(notificationService);
}

// 実際の使用
const orderService = createOrderService();
orderService.createOrder('123', 'product-456');
```

## 改善のポイント

### 1. インターフェースによる抽象化

```typescript
interface NotificationChannel {
  send(recipient: string, message: string): Promise<void>;
  getChannelName(): string;
}
```

- 具体的な実装ではなく、抽象に依存（依存性逆転の原則）
- 新しい通知方法を追加する際、既存コードを変更する必要がない

### 2. 依存性注入（DI）

```typescript
constructor(notificationService: NotificationService) {
  this.notificationService = notificationService;
}
```

- コンストラクタで依存を外部から注入
- テスト時にモックに差し替え可能
- 設定の変更が容易

### 3. オープン・クローズドの原則

- 拡張に対して開いている: 新しいチャネルを追加できる
- 修正に対して閉じている: 既存コードを変更せずに拡張可能

### 4. 単一責任の原則

- `NotificationService`: 通知の送信のみを担当
- `UserRepository`: ユーザー情報の取得のみを担当
- `OrderService`: 注文処理のみを担当

## さらなる改善案

### DIコンテナの活用

```typescript
/**
 * シンプルなDIコンテナ
 */
class Container {
  private services: Map<string, any> = new Map();
  
  register<T>(name: string, instance: T): void {
    this.services.set(name, instance);
  }
  
  resolve<T>(name: string): T {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not found`);
    }
    return service;
  }
}

// セットアップ
const container = new Container();
container.register('userRepository', new UserRepositoryImpl());
container.register('emailChannel', new EmailChannel());
container.register('smsChannel', new SMSChannel());

const notificationService = new NotificationService({
  channels: [
    container.resolve('emailChannel'),
    container.resolve('smsChannel'),
  ],
  userRepository: container.resolve('userRepository'),
});

container.register('notificationService', notificationService);
container.register('orderService', new OrderService(
  container.resolve('notificationService')
));

// 使用
const orderService = container.resolve<OrderService>('orderService');
```

### ファクトリーパターンの活用

```typescript
/**
 * 通知チャネルファクトリー
 */
class NotificationChannelFactory {
  private static channels: Map<string, () => NotificationChannel> = new Map([
    ['email', () => new EmailChannel()],
    ['sms', () => new SMSChannel()],
    ['push', () => new PushChannel()],
  ]);
  
  static createChannel(type: string): NotificationChannel {
    const factory = this.channels.get(type);
    if (!factory) {
      throw new Error(`Unknown channel type: ${type}`);
    }
    return factory();
  }
  
  static createChannels(types: string[]): NotificationChannel[] {
    return types.map(type => this.createChannel(type));
  }
}

// 使用例
const channels = NotificationChannelFactory.createChannels(['email', 'sms', 'push']);
```

### テストの例

```typescript
/**
 * モックチャネル（テスト用）
 */
class MockNotificationChannel implements NotificationChannel {
  public sentMessages: Array<{ recipient: string; message: string }> = [];
  
  async send(recipient: string, message: string): Promise<void> {
    this.sentMessages.push({ recipient, message });
  }
  
  getChannelName(): string {
    return 'mock';
  }
}

/**
 * モックユーザーリポジトリ（テスト用）
 */
class MockUserRepository implements UserRepository {
  async getEmail(userId: string): Promise<string> {
    return `mock${userId}@test.com`;
  }
  
  async getPhoneNumber(userId: string): Promise<string> {
    return `000-0000-${userId}`;
  }
}

// テストコード
async function testOrderService() {
  const mockChannel = new MockNotificationChannel();
  const mockUserRepo = new MockUserRepository();
  
  const notificationService = new NotificationService({
    channels: [mockChannel],
    userRepository: mockUserRepo,
  });
  
  const orderService = new OrderService(notificationService);
  
  await orderService.createOrder('123', 'product-456');
  
  // 検証
  console.assert(
    mockChannel.sentMessages.length === 1,
    'Should send 1 notification'
  );
  console.assert(
    mockChannel.sentMessages[0].recipient === 'mock123@test.com',
    'Should send to correct email'
  );
}
```

## 学んだこと

1. **依存性逆転の原則（DIP）**
   - 具体ではなく抽象に依存する
   - インターフェースを使って実装を隠蔽

2. **依存性注入（DI）の威力**
   - テストが容易になる
   - 設定の変更が柔軟に

3. **オープン・クローズドの原則**
   - 拡張に対して開き、修正に対して閉じる
   - 新機能追加時に既存コードを変更しない

4. **単一責任の原則**
   - 各クラスが1つの責務のみを持つ
   - 変更の理由が1つになる

## 疎結合のチェックリスト

- [ ] インターフェースを定義しているか？
- [ ] コンストラクタで依存を注入しているか？
- [ ] クラス内で`new`を使っていないか？
- [ ] モックに差し替えてテストできるか？
- [ ] 新機能追加時に既存コードを変更する必要がないか？
