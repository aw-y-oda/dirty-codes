# ヒント

## このコードの問題点

このコードには「巨大な関数（神関数/God Function）」というアンチパターンが含まれています。

### 具体的な問題

1. **単一責任の原則違反**
   - `processOrder`メソッドが150行以上あり、複数の責務を持っています
   - バリデーション、ビジネスロジック、データ永続化、通知など、すべてを1つの関数で処理しています

2. **テストが困難**
   - 1つの巨大な関数をテストするには、すべての依存関係をモックする必要があります
   - 部分的なテストができません

3. **可読性の低下**
   - コードが長すぎて、全体の流れを把握するのが困難です
   - どこで何をしているのか追いかけるのが大変です

4. **再利用性の欠如**
   - バリデーションロジックなど、他の場所でも使いたい処理が埋め込まれています
   - 抽出して再利用することができません

5. **変更の影響範囲が大きい**
   - 1つの機能を変更するだけでも、巨大な関数全体を理解する必要があります
   - バグを混入させるリスクが高くなります

## リファクタリングのアプローチ

### 1. 責務ごとにメソッドを分割する

関数が行っている処理を責務ごとに分類してみましょう:

- **入力バリデーション**: 顧客情報、商品情報、支払い方法の検証
- **在庫確認**: 商品の在庫状況と販売状態の確認
- **金額計算**: 小計、割引、送料、合計金額の計算
- **データ永続化**: 顧客、注文、注文明細の保存
- **在庫更新**: 商品在庫数の減算
- **通知**: メール送信
- **日付計算**: 配送予定日の算出

これらの責務を個別のメソッドやクラスに分割することを検討してください。

### 2. バリデーションの抽出

バリデーション処理は、独立したバリデータークラスやメソッドに分離できます:

```typescript
class OrderValidator {
  validateCustomerInfo(request: OrderRequest): ValidationResult {
    // 顧客情報のバリデーション
  }

  validateItems(items: OrderItem[]): ValidationResult {
    // 商品情報のバリデーション
  }

  validatePaymentMethod(method: string): ValidationResult {
    // 支払い方法のバリデーション
  }
}
```

### 3. ビジネスロジックの分離

金額計算などのビジネスロジックは、専門のサービスやヘルパークラスに分離できます:

```typescript
class PriceCalculator {
  calculateSubtotal(items: OrderItem[]): number {
    // 小計計算
  }

  calculateDiscount(subtotal: number, coupon?: Coupon): number {
    // 割引計算
  }

  calculateShippingFee(subtotal: number): number {
    // 送料計算
  }
}
```

### 4. データアクセスの抽象化

データベース操作は、リポジトリパターンを使って分離できます:

```typescript
class OrderRepository {
  async save(order: Order): Promise<number> {
    // 注文の保存
  }

  async saveItems(orderId: number, items: OrderItem[]): Promise<void> {
    // 注文明細の保存
  }
}
```

### 5. コマンドパターンの適用

注文処理の各ステップをコマンドとして表現することも検討できます:

```typescript
interface OrderCommand {
  execute(context: OrderContext): Promise<void>;
}

class ValidateOrderCommand implements OrderCommand {
  async execute(context: OrderContext): Promise<void> {
    // バリデーション実行
  }
}

class CalculatePriceCommand implements OrderCommand {
  async execute(context: OrderContext): Promise<void> {
    // 金額計算実行
  }
}
```

## 考えてみましょう

1. この関数をいくつのメソッドに分割すべきでしょうか？
2. どのような単位でクラスを分けるのが適切でしょうか？
3. 各メソッドの入力と出力は何になるべきでしょうか？
4. エラーハンドリングはどのように統一すべきでしょうか？
5. トランザクション管理はどこで行うべきでしょうか？

## 参考キーワード

- 単一責任の原則 (Single Responsibility Principle)
- 関数の分割 (Function Decomposition)
- リポジトリパターン (Repository Pattern)
- サービス層 (Service Layer)
- バリデータパターン (Validator Pattern)
- コマンドパターン (Command Pattern)
- 関心の分離 (Separation of Concerns)
