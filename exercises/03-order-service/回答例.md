# 回答例

## リファクタリング後のコード

### 1. 型定義の整理

```typescript
interface OrderRequest {
  customerId: number;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  shippingAddress: string;
  shippingPostalCode: string;
  items: Array<{
    productId: number;
    quantity: number;
    price: number;
  }>;
  paymentMethod: string;
  couponCode?: string;
}

interface OrderResponse {
  orderId: number;
  totalAmount: number;
  discountAmount: number;
  finalAmount: number;
  estimatedDeliveryDate: string;
}

interface ValidationResult {
  isValid: boolean;
  error?: string;
}

interface Coupon {
  code: string;
  expiryDate: string;
  minOrderAmount?: number;
  usageLimit?: number;
  usedCount: number;
  discountType: "percentage" | "fixed";
  discountValue: number;
  maxDiscountAmount?: number;
}

interface Product {
  id: number;
  name: string;
  stock: number;
  isActive: boolean;
}

interface PriceBreakdown {
  subtotal: number;
  discountAmount: number;
  shippingFee: number;
  finalAmount: number;
}
```

### 2. バリデータークラス

```typescript
class OrderValidator {
  validateCustomerInfo(request: OrderRequest): ValidationResult {
    const nameValidation = this.validateCustomerName(request.customerName);
    if (!nameValidation.isValid) return nameValidation;

    const emailValidation = this.validateEmail(request.customerEmail);
    if (!emailValidation.isValid) return emailValidation;

    const phoneValidation = this.validatePhone(request.customerPhone);
    if (!phoneValidation.isValid) return phoneValidation;

    return { isValid: true };
  }

  validateShippingInfo(request: OrderRequest): ValidationResult {
    if (!request.shippingAddress || request.shippingAddress.trim() === "") {
      return { isValid: false, error: "配送先住所を入力してください" };
    }
    if (request.shippingAddress.length < 5) {
      return { isValid: false, error: "配送先住所を正しく入力してください" };
    }

    if (
      !request.shippingPostalCode ||
      request.shippingPostalCode.trim() === ""
    ) {
      return { isValid: false, error: "郵便番号を入力してください" };
    }
    if (!/^\d{3}-?\d{4}$/.test(request.shippingPostalCode)) {
      return { isValid: false, error: "正しい郵便番号を入力してください" };
    }

    return { isValid: true };
  }

  validateItems(items: OrderRequest["items"]): ValidationResult {
    if (!items || items.length === 0) {
      return { isValid: false, error: "商品を選択してください" };
    }

    for (const item of items) {
      if (item.quantity <= 0) {
        return { isValid: false, error: "商品の数量は1以上で入力してください" };
      }
      if (item.quantity > 999) {
        return {
          isValid: false,
          error: "商品の数量は999以下で入力してください",
        };
      }
      if (item.price <= 0) {
        return { isValid: false, error: "不正な価格が設定されています" };
      }
    }

    return { isValid: true };
  }

  validatePaymentMethod(paymentMethod: string): ValidationResult {
    if (!paymentMethod || paymentMethod.trim() === "") {
      return { isValid: false, error: "支払い方法を選択してください" };
    }

    const validMethods = [
      "credit_card",
      "bank_transfer",
      "cash_on_delivery",
      "convenience_store",
    ];

    if (!validMethods.includes(paymentMethod)) {
      return { isValid: false, error: "不正な支払い方法です" };
    }

    return { isValid: true };
  }

  private validateCustomerName(name: string): ValidationResult {
    if (!name || name.trim() === "") {
      return { isValid: false, error: "顧客名を入力してください" };
    }
    if (name.length < 2) {
      return { isValid: false, error: "顧客名は2文字以上で入力してください" };
    }
    if (name.length > 50) {
      return { isValid: false, error: "顧客名は50文字以内で入力してください" };
    }
    return { isValid: true };
  }

  private validateEmail(email: string): ValidationResult {
    if (!email || email.trim() === "") {
      return { isValid: false, error: "メールアドレスを入力してください" };
    }
    if (!email.includes("@") || !email.includes(".")) {
      return { isValid: false, error: "正しいメールアドレスを入力してください" };
    }
    return { isValid: true };
  }

  private validatePhone(phone: string): ValidationResult {
    if (!phone || phone.trim() === "") {
      return { isValid: false, error: "電話番号を入力してください" };
    }
    if (phone.length < 10) {
      return { isValid: false, error: "正しい電話番号を入力してください" };
    }
    return { isValid: true };
  }
}
```

### 3. 商品バリデーター

```typescript
class ProductValidator {
  async validateProductAvailability(
    items: OrderRequest["items"],
    getProduct: (id: number) => Promise<Product | null>
  ): Promise<ValidationResult> {
    for (const item of items) {
      const product = await getProduct(item.productId);

      if (!product) {
        return {
          isValid: false,
          error: `商品ID ${item.productId} が見つかりません`,
        };
      }

      if (product.stock < item.quantity) {
        return {
          isValid: false,
          error: `商品「${product.name}」の在庫が不足しています`,
        };
      }

      if (!product.isActive) {
        return {
          isValid: false,
          error: `商品「${product.name}」は現在販売停止中です`,
        };
      }
    }

    return { isValid: true };
  }
}
```

### 4. 価格計算サービス

```typescript
class PriceCalculator {
  calculateSubtotal(items: OrderRequest["items"]): number {
    return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
  }

  async calculateDiscount(
    subtotal: number,
    couponCode: string | undefined,
    getCoupon: (code: string) => Promise<Coupon | null>
  ): Promise<{ amount: number; error?: string }> {
    if (!couponCode) {
      return { amount: 0 };
    }

    const coupon = await getCoupon(couponCode);
    if (!coupon) {
      return { amount: 0 };
    }

    const validation = this.validateCoupon(coupon, subtotal);
    if (!validation.isValid) {
      return { amount: 0, error: validation.error };
    }

    return { amount: this.calculateCouponDiscount(coupon, subtotal) };
  }

  calculateShippingFee(subtotal: number): number {
    if (subtotal < 5000) return 800;
    if (subtotal < 10000) return 500;
    return 0;
  }

  calculatePriceBreakdown(
    subtotal: number,
    discountAmount: number,
    shippingFee: number
  ): PriceBreakdown {
    return {
      subtotal,
      discountAmount,
      shippingFee,
      finalAmount: subtotal - discountAmount + shippingFee,
    };
  }

  private validateCoupon(coupon: Coupon, subtotal: number): ValidationResult {
    if (new Date(coupon.expiryDate) < new Date()) {
      return { isValid: false, error: "このクーポンは有効期限切れです" };
    }

    if (coupon.minOrderAmount && subtotal < coupon.minOrderAmount) {
      return {
        isValid: false,
        error: `このクーポンは${coupon.minOrderAmount}円以上の注文で使用できます`,
      };
    }

    if (coupon.usageLimit && coupon.usedCount >= coupon.usageLimit) {
      return { isValid: false, error: "このクーポンは使用上限に達しています" };
    }

    return { isValid: true };
  }

  private calculateCouponDiscount(coupon: Coupon, subtotal: number): number {
    if (coupon.discountType === "percentage") {
      let discount = subtotal * (coupon.discountValue / 100);
      if (coupon.maxDiscountAmount && discount > coupon.maxDiscountAmount) {
        discount = coupon.maxDiscountAmount;
      }
      return discount;
    }

    if (coupon.discountType === "fixed") {
      return coupon.discountValue;
    }

    return 0;
  }
}
```

### 5. 配送日計算サービス

```typescript
class DeliveryDateCalculator {
  calculateEstimatedDeliveryDate(daysToAdd: number = 3): string {
    const today = new Date();
    const deliveryDate = new Date(today);
    deliveryDate.setDate(today.getDate() + daysToAdd);

    return this.formatDate(deliveryDate);
  }

  private formatDate(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
}
```

### 6. 注文リポジトリ

```typescript
class OrderRepository {
  async saveCustomer(customer: {
    id: number;
    name: string;
    email: string;
    phone: string;
  }): Promise<number> {
    // データベースに顧客情報を保存
    return customer.id;
  }

  async saveOrder(order: {
    customerId: number;
    totalAmount: number;
    discountAmount: number;
    shippingFee: number;
    finalAmount: number;
    status: string;
    paymentMethod: string;
    shippingAddress: string;
    shippingPostalCode: string;
  }): Promise<number> {
    // データベースに注文を保存
    return Math.floor(Math.random() * 100000);
  }

  async saveOrderItems(
    orderId: number,
    items: OrderRequest["items"]
  ): Promise<void> {
    for (const item of items) {
      await this.saveOrderItem({
        orderId,
        productId: item.productId,
        quantity: item.quantity,
        price: item.price,
      });
    }
  }

  private async saveOrderItem(item: {
    orderId: number;
    productId: number;
    quantity: number;
    price: number;
  }): Promise<void> {
    // データベースに注文明細を保存
  }
}
```

### 7. 在庫管理サービス

```typescript
class StockManager {
  async updateStockForOrder(items: OrderRequest["items"]): Promise<void> {
    for (const item of items) {
      await this.updateStock(item.productId, -item.quantity);
    }
  }

  private async updateStock(
    productId: number,
    quantityDelta: number
  ): Promise<void> {
    // 在庫を更新
  }
}
```

### 8. 通知サービス

```typescript
class NotificationService {
  async sendOrderConfirmationEmail(
    email: string,
    orderId: number
  ): Promise<void> {
    // メール送信処理
  }
}
```

### 9. クーポンサービス

```typescript
class CouponService {
  async getCouponByCode(code: string): Promise<Coupon | null> {
    // データベースからクーポンを取得
    return null;
  }

  async incrementCouponUsage(code: string): Promise<void> {
    // クーポンの使用回数をインクリメント
  }
}
```

### 10. リファクタリング後のOrderService

```typescript
class OrderService {
  constructor(
    private validator: OrderValidator,
    private productValidator: ProductValidator,
    private priceCalculator: PriceCalculator,
    private deliveryCalculator: DeliveryDateCalculator,
    private orderRepository: OrderRepository,
    private stockManager: StockManager,
    private notificationService: NotificationService,
    private couponService: CouponService,
    private getProduct: (id: number) => Promise<Product | null>
  ) {}

  async processOrder(
    request: OrderRequest
  ): Promise<OrderResponse | { error: string }> {
    // 1. 入力バリデーション
    const validationResult = this.validateOrder(request);
    if (!validationResult.isValid) {
      return { error: validationResult.error! };
    }

    // 2. 商品の在庫確認
    const productValidation =
      await this.productValidator.validateProductAvailability(
        request.items,
        this.getProduct
      );
    if (!productValidation.isValid) {
      return { error: productValidation.error! };
    }

    // 3. 金額計算
    const priceBreakdown = await this.calculatePrice(request);
    if ("error" in priceBreakdown) {
      return { error: priceBreakdown.error };
    }

    // 4. データ保存
    const orderId = await this.saveOrderData(request, priceBreakdown);

    // 5. 在庫更新
    await this.stockManager.updateStockForOrder(request.items);

    // 6. クーポン使用回数更新
    if (request.couponCode) {
      await this.couponService.incrementCouponUsage(request.couponCode);
    }

    // 7. 確認メール送信
    await this.notificationService.sendOrderConfirmationEmail(
      request.customerEmail,
      orderId
    );

    // 8. 配送予定日計算
    const estimatedDeliveryDate =
      this.deliveryCalculator.calculateEstimatedDeliveryDate();

    return {
      orderId,
      totalAmount: priceBreakdown.subtotal,
      discountAmount: priceBreakdown.discountAmount,
      finalAmount: priceBreakdown.finalAmount,
      estimatedDeliveryDate,
    };
  }

  private validateOrder(request: OrderRequest): ValidationResult {
    const customerValidation = this.validator.validateCustomerInfo(request);
    if (!customerValidation.isValid) return customerValidation;

    const shippingValidation = this.validator.validateShippingInfo(request);
    if (!shippingValidation.isValid) return shippingValidation;

    const itemsValidation = this.validator.validateItems(request.items);
    if (!itemsValidation.isValid) return itemsValidation;

    const paymentValidation = this.validator.validatePaymentMethod(
      request.paymentMethod
    );
    if (!paymentValidation.isValid) return paymentValidation;

    return { isValid: true };
  }

  private async calculatePrice(
    request: OrderRequest
  ): Promise<PriceBreakdown | { error: string }> {
    const subtotal = this.priceCalculator.calculateSubtotal(request.items);

    const discountResult = await this.priceCalculator.calculateDiscount(
      subtotal,
      request.couponCode,
      this.couponService.getCouponByCode.bind(this.couponService)
    );

    if (discountResult.error) {
      return { error: discountResult.error };
    }

    const shippingFee = this.priceCalculator.calculateShippingFee(subtotal);

    return this.priceCalculator.calculatePriceBreakdown(
      subtotal,
      discountResult.amount,
      shippingFee
    );
  }

  private async saveOrderData(
    request: OrderRequest,
    priceBreakdown: PriceBreakdown
  ): Promise<number> {
    // 顧客情報保存
    await this.orderRepository.saveCustomer({
      id: request.customerId,
      name: request.customerName,
      email: request.customerEmail,
      phone: request.customerPhone,
    });

    // 注文保存
    const orderId = await this.orderRepository.saveOrder({
      customerId: request.customerId,
      totalAmount: priceBreakdown.subtotal,
      discountAmount: priceBreakdown.discountAmount,
      shippingFee: priceBreakdown.shippingFee,
      finalAmount: priceBreakdown.finalAmount,
      status: "pending",
      paymentMethod: request.paymentMethod,
      shippingAddress: request.shippingAddress,
      shippingPostalCode: request.shippingPostalCode,
    });

    // 注文明細保存
    await this.orderRepository.saveOrderItems(orderId, request.items);

    return orderId;
  }
}
```

## リファクタリングのポイント

### 1. 単一責任の原則の適用

元の`processOrder`メソッドは150行以上あり、以下のすべてを担当していました:

- 入力バリデーション
- ビジネスルール検証
- 金額計算
- データ永続化
- 通知

これを責務ごとに分割し、各クラスが1つの責任だけを持つようにしました。

### 2. 依存性の注入

コンストラクタで依存オブジェクトを受け取ることで:

- テストが容易になる（モックを注入できる）
- 各コンポーネントが疎結合になる
- 再利用性が向上する

### 3. メソッドの小型化

各メソッドを以下のように短く保ちました:

- 1つのメソッドは1つのことだけを行う
- メソッド名が処理内容を明確に表現している
- ネストを深くしない

### 4. 計算ロジックの抽出

`PriceCalculator`クラスに金額計算を集約することで:

- ビジネスロジックのテストが容易
- 計算方法の変更が局所化される
- 他の場所でも再利用可能

### 5. データアクセスの抽象化

`OrderRepository`パターンを使用することで:

- ビジネスロジックからデータアクセスを分離
- データベースの変更がビジネスロジックに影響しない
- テスト時にモックリポジトリを簡単に作成できる

## メリット

### テスタビリティの向上

各コンポーネントを個別にユニットテストできます:

```typescript
describe("PriceCalculator", () => {
  it("小計を正しく計算する", () => {
    const calculator = new PriceCalculator();
    const items = [
      { productId: 1, quantity: 2, price: 1000 },
      { productId: 2, quantity: 1, price: 2000 },
    ];
    expect(calculator.calculateSubtotal(items)).toBe(4000);
  });
});
```

### 可読性の向上

`processOrder`メソッドが明確なステップに分かれ、何をしているか一目で理解できます。

### 保守性の向上

- バリデーションルールの変更 → `OrderValidator`だけを修正
- 送料計算の変更 → `PriceCalculator`だけを修正
- 通知方法の変更 → `NotificationService`だけを修正

### 再利用性の向上

各コンポーネントは他のコンテキストでも使用できます:

- `OrderValidator`は他のAPIエンドポイントでも使える
- `PriceCalculator`は見積もり機能でも使える
- `DeliveryDateCalculator`は配送状況確認でも使える

## まとめ

巨大な関数を分割することで:

1. **コードの理解が容易になる**: 各部分が何をしているか明確
2. **テストが書きやすくなる**: 個別のユニットテストが可能
3. **変更に強くなる**: 影響範囲が限定される
4. **再利用しやすくなる**: コンポーネントを他の場所でも使える
5. **チーム開発がしやすくなる**: 担当箇所を明確に分担できる

「1つのメソッドは1つのことだけを行う」という原則を守ることで、保守性と拡張性の高いコードになります。
