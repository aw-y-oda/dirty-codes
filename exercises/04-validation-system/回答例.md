# 回答例: コードの重複（DRY原則違反）

## リファクタリング後のコード

```typescript
/**
 * バリデーションルールの型定義
 */
interface ValidationRule<T> {
  validate: (value: T) => boolean;
  errorMessage: string;
}

/**
 * 汎用バリデータークラス
 */
class Validator<T> {
  private rules: ValidationRule<T>[] = [];
  
  addRule(rule: ValidationRule<T>): this {
    this.rules.push(rule);
    return this;
  }
  
  validate(value: T): string[] {
    const errors: string[] = [];
    
    for (const rule of this.rules) {
      if (!rule.validate(value)) {
        errors.push(rule.errorMessage);
      }
    }
    
    return errors;
  }
}

/**
 * よく使うバリデーションルールのファクトリー
 */
class ValidationRules {
  static required<T>(fieldName: string): ValidationRule<T> {
    return {
      validate: (value: T) => value !== null && value !== undefined && value !== '',
      errorMessage: `${fieldName}は必須です`,
    };
  }
  
  static minLength(fieldName: string, min: number): ValidationRule<string> {
    return {
      validate: (value: string) => value.length >= min,
      errorMessage: `${fieldName}は${min}文字以上である必要があります`,
    };
  }
  
  static maxLength(fieldName: string, max: number): ValidationRule<string> {
    return {
      validate: (value: string) => value.length <= max,
      errorMessage: `${fieldName}は${max}文字以内である必要があります`,
    };
  }
  
  static minValue(fieldName: string, min: number): ValidationRule<number> {
    return {
      validate: (value: number) => value >= min,
      errorMessage: `${fieldName}は${min}以上である必要があります`,
    };
  }
  
  static maxValue(fieldName: string, max: number): ValidationRule<number> {
    return {
      validate: (value: number) => value <= max,
      errorMessage: `${fieldName}は${max}以下である必要があります`,
    };
  }
  
  static pattern(fieldName: string, pattern: RegExp, message?: string): ValidationRule<string> {
    return {
      validate: (value: string) => pattern.test(value),
      errorMessage: message || `${fieldName}の形式が不正です`,
    };
  }
  
  static email(fieldName: string): ValidationRule<string> {
    return this.pattern(
      fieldName,
      /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      `${fieldName}の形式が不正です`
    );
  }
}

/**
 * ユーザーバリデーター
 */
class UserValidator {
  private nameValidator = new Validator<string>()
    .addRule(ValidationRules.required('名前'))
    .addRule(ValidationRules.minLength('名前', 2))
    .addRule(ValidationRules.maxLength('名前', 50));
  
  private emailValidator = new Validator<string>()
    .addRule(ValidationRules.required('メールアドレス'))
    .addRule(ValidationRules.minLength('メールアドレス', 5))
    .addRule(ValidationRules.maxLength('メールアドレス', 100))
    .addRule(ValidationRules.email('メールアドレス'));
  
  private ageValidator = new Validator<number>()
    .addRule(ValidationRules.required('年齢'))
    .addRule(ValidationRules.minValue('年齢', 0))
    .addRule(ValidationRules.maxValue('年齢', 150));
  
  validateUserName(name: string): string[] {
    return this.nameValidator.validate(name);
  }
  
  validateEmail(email: string): string[] {
    return this.emailValidator.validate(email);
  }
  
  validateAge(age: number): string[] {
    return this.ageValidator.validate(age);
  }
}

/**
 * 商品バリデーター
 */
class ProductValidator {
  private nameValidator = new Validator<string>()
    .addRule(ValidationRules.required('商品名'))
    .addRule(ValidationRules.minLength('商品名', 2))
    .addRule(ValidationRules.maxLength('商品名', 100));
  
  private priceValidator = new Validator<number>()
    .addRule(ValidationRules.required('価格'))
    .addRule(ValidationRules.minValue('価格', 0))
    .addRule(ValidationRules.maxValue('価格', 10000000));
  
  private stockValidator = new Validator<number>()
    .addRule(ValidationRules.required('在庫数'))
    .addRule(ValidationRules.minValue('在庫数', 0))
    .addRule(ValidationRules.maxValue('在庫数', 100000));
  
  validateProductName(name: string): string[] {
    return this.nameValidator.validate(name);
  }
  
  validatePrice(price: number): string[] {
    return this.priceValidator.validate(price);
  }
  
  validateStock(stock: number): string[] {
    return this.stockValidator.validate(stock);
  }
}
```

## 改善のポイント

### 1. ジェネリクスを使った型安全な共通バリデーター

- `Validator<T>`クラスで、任意の型に対応できる汎用バリデーターを実装
- TypeScriptの型システムにより、文字列と数値のバリデーションを型安全に扱える

### 2. ファクトリーパターンによるルールの再利用

- `ValidationRules`クラスでよく使うルールを提供
- 新しいバリデーションルールを追加する際も一箇所に集約

### 3. Fluent Interface（メソッドチェーン）

- `addRule()`メソッドが`this`を返すことで、直感的なルール定義が可能
- 読みやすく、保守しやすいコード

### 4. コードの大幅な削減

- 元のコード: 約130行
- リファクタリング後: 約100行（機能は同じまま）
- さらに拡張性が大幅に向上

## さらなる改善案

### オブジェクト全体のバリデーション

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
  role: string;
}

interface ValidationErrors {
  [key: string]: string[];
}

class UserValidator {
  validateUser(user: User): ValidationErrors {
    const errors: ValidationErrors = {};
    
    const nameErrors = this.validateUserName(user.name);
    if (nameErrors.length > 0) {
      errors.name = nameErrors;
    }
    
    const emailErrors = this.validateEmail(user.email);
    if (emailErrors.length > 0) {
      errors.email = emailErrors;
    }
    
    const ageErrors = this.validateAge(user.age);
    if (ageErrors.length > 0) {
      errors.age = ageErrors;
    }
    
    return errors;
  }
}
```

### デコレータを使ったバリデーション（上級編）

```typescript
function Validate(validator: Validator<any>) {
  return function (target: any, propertyKey: string) {
    // バリデーションロジックをデコレータで実装
  };
}

class User {
  @Validate(new Validator<string>()
    .addRule(ValidationRules.required('名前'))
    .addRule(ValidationRules.minLength('名前', 2))
    .addRule(ValidationRules.maxLength('名前', 50)))
  name: string;
  
  // 他のプロパティも同様に...
}
```

## 学んだこと

1. **DRY原則（Don't Repeat Yourself）の重要性**
   - 重複を排除することで、保守性と拡張性が向上
   
2. **ジェネリクスの活用**
   - 型安全性を保ちながら汎用的なコードを書ける
   
3. **デザインパターンの適用**
   - ファクトリーパターン、Fluent Interfaceなどが実用的
   
4. **関心の分離**
   - バリデーションロジックとルール定義を分離することで、各々が独立して変更可能に
