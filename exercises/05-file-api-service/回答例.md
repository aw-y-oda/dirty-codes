# 回答例: エラーハンドリングの欠如

## リファクタリング後のコード

```typescript
/**
 * カスタムエラークラス
 */
class FileError extends Error {
  constructor(message: string, public readonly path: string) {
    super(message);
    this.name = 'FileError';
  }
}

class NetworkError extends Error {
  constructor(
    message: string,
    public readonly statusCode?: number,
    public readonly url?: string
  ) {
    super(message);
    this.name = 'NetworkError';
  }
}

class ValidationError extends Error {
  constructor(message: string, public readonly errors: string[]) {
    super(message);
    this.name = 'ValidationError';
  }
}

/**
 * 処理結果の型定義
 */
interface Result<T> {
  success: boolean;
  data?: T;
  error?: Error;
}

interface BatchResult<T> {
  successful: T[];
  failed: Array<{ item: any; error: Error }>;
}

/**
 * ロガーインターフェース
 */
interface Logger {
  info(message: string, meta?: any): void;
  warn(message: string, meta?: any): void;
  error(message: string, meta?: any): void;
}

/**
 * シンプルなロガー実装
 */
class ConsoleLogger implements Logger {
  info(message: string, meta?: any): void {
    console.log(`[INFO] ${message}`, meta || '');
  }
  
  warn(message: string, meta?: any): void {
    console.warn(`[WARN] ${message}`, meta || '');
  }
  
  error(message: string, meta?: any): void {
    console.error(`[ERROR] ${message}`, meta || '');
  }
}

interface User {
  id: string;
  name: string;
  email: string;
}

/**
 * ファイルサービス（エラーハンドリング付き）
 */
class FileService {
  constructor(private logger: Logger) {}
  
  readFile(path: string): Result<string> {
    try {
      this.logger.info('Reading file', { path });
      
      // 実際のファイル読み込み処理
      // ここでは簡略化のため、固定値を返す
      const content = '{"users": [{"id": "1", "name": "John", "email": "john@example.com"}]}';
      
      return { success: true, data: content };
    } catch (error) {
      const fileError = new FileError(
        `Failed to read file: ${path}`,
        path
      );
      this.logger.error('File read failed', { path, error });
      return { success: false, error: fileError };
    }
  }
  
  writeFile(path: string, content: string): Result<void> {
    try {
      this.logger.info('Writing file', { path, size: content.length });
      
      // 実際のファイル書き込み処理
      console.log(`Writing to ${path}`);
      
      return { success: true };
    } catch (error) {
      const fileError = new FileError(
        `Failed to write file: ${path}`,
        path
      );
      this.logger.error('File write failed', { path, error });
      return { success: false, error: fileError };
    }
  }
  
  deleteFile(path: string): Result<void> {
    try {
      this.logger.info('Deleting file', { path });
      
      // 実際のファイル削除処理
      console.log(`Deleting ${path}`);
      
      return { success: true };
    } catch (error) {
      const fileError = new FileError(
        `Failed to delete file: ${path}`,
        path
      );
      this.logger.error('File delete failed', { path, error });
      return { success: false, error: fileError };
    }
  }
}

/**
 * APIサービス（エラーハンドリング付き）
 */
class ApiService {
  constructor(private logger: Logger) {}
  
  async fetchUser(userId: string): Promise<Result<User>> {
    try {
      this.logger.info('Fetching user', { userId });
      
      const response = await fetch(`https://api.example.com/users/${userId}`);
      
      if (!response.ok) {
        throw new NetworkError(
          `Failed to fetch user: ${response.statusText}`,
          response.status,
          response.url
        );
      }
      
      const data = await response.json();
      
      // データ検証
      if (!this.isValidUser(data)) {
        throw new ValidationError(
          'Invalid user data',
          ['User data does not match expected schema']
        );
      }
      
      return { success: true, data };
    } catch (error) {
      this.logger.error('User fetch failed', { userId, error });
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }
  
  async updateUser(user: User): Promise<Result<void>> {
    try {
      this.logger.info('Updating user', { userId: user.id });
      
      const response = await fetch(`https://api.example.com/users/${user.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(user),
      });
      
      if (!response.ok) {
        throw new NetworkError(
          `Failed to update user: ${response.statusText}`,
          response.status,
          response.url
        );
      }
      
      return { success: true };
    } catch (error) {
      this.logger.error('User update failed', { userId: user.id, error });
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }
  
  private isValidUser(data: any): data is User {
    return (
      typeof data === 'object' &&
      data !== null &&
      typeof data.id === 'string' &&
      typeof data.name === 'string' &&
      typeof data.email === 'string'
    );
  }
}

/**
 * ユーザーデータサービス（エラーハンドリング付き）
 */
class UserDataService {
  private fileService: FileService;
  private apiService: ApiService;
  private logger: Logger;
  
  constructor(logger: Logger) {
    this.logger = logger;
    this.fileService = new FileService(logger);
    this.apiService = new ApiService(logger);
  }
  
  /**
   * ファイルからユーザーを読み込む
   */
  loadUsersFromFile(filePath: string): Result<User[]> {
    try {
      const fileResult = this.fileService.readFile(filePath);
      
      if (!fileResult.success || !fileResult.data) {
        return { success: false, error: fileResult.error };
      }
      
      const data = JSON.parse(fileResult.data);
      
      if (!Array.isArray(data.users)) {
        throw new ValidationError(
          'Invalid file format',
          ['Expected "users" array in JSON']
        );
      }
      
      return { success: true, data: data.users };
    } catch (error) {
      if (error instanceof SyntaxError) {
        this.logger.error('JSON parse failed', { filePath, error });
        return {
          success: false,
          error: new ValidationError('Invalid JSON format', [error.message]),
        };
      }
      
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }
  
  /**
   * ユーザーデータを同期する
   */
  async syncUserData(userId: string, localPath: string): Promise<Result<User>> {
    try {
      this.logger.info('Syncing user data', { userId, localPath });
      
      // ローカルファイルから読み込み
      const localResult = this.fileService.readFile(localPath);
      let localUser: Partial<User> = {};
      
      if (localResult.success && localResult.data) {
        try {
          localUser = JSON.parse(localResult.data);
        } catch (error) {
          this.logger.warn('Failed to parse local file, using empty object', {
            localPath,
            error,
          });
        }
      } else {
        this.logger.warn('Failed to read local file, using empty object', {
          localPath,
          error: localResult.error,
        });
      }
      
      // APIからデータを取得
      const remoteResult = await this.apiService.fetchUser(userId);
      
      if (!remoteResult.success || !remoteResult.data) {
        return { success: false, error: remoteResult.error };
      }
      
      // データをマージ
      const mergedUser: User = {
        ...remoteResult.data,
        ...localUser,
        id: userId, // IDは変更不可
      };
      
      // APIに更新
      const updateResult = await this.apiService.updateUser(mergedUser);
      
      if (!updateResult.success) {
        return { success: false, error: updateResult.error };
      }
      
      // ローカルファイルを更新
      const writeResult = this.fileService.writeFile(
        localPath,
        JSON.stringify(mergedUser, null, 2)
      );
      
      if (!writeResult.success) {
        this.logger.warn('Failed to update local file', {
          localPath,
          error: writeResult.error,
        });
        // ローカルファイルの更新に失敗しても、同期自体は成功とみなす
      }
      
      return { success: true, data: mergedUser };
    } catch (error) {
      this.logger.error('User sync failed', { userId, localPath, error });
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error)),
      };
    }
  }
  
  /**
   * ユーザーをバッチ更新する
   */
  async batchUpdateUsers(userIds: string[]): Promise<BatchResult<User>> {
    this.logger.info('Starting batch update', { count: userIds.length });
    
    const result: BatchResult<User> = {
      successful: [],
      failed: [],
    };
    
    for (const userId of userIds) {
      try {
        const fetchResult = await this.apiService.fetchUser(userId);
        
        if (!fetchResult.success || !fetchResult.data) {
          result.failed.push({
            item: userId,
            error: fetchResult.error || new Error('Unknown error'),
          });
          continue;
        }
        
        const user = fetchResult.data;
        user.name = user.name.toUpperCase();
        
        const updateResult = await this.apiService.updateUser(user);
        
        if (!updateResult.success) {
          result.failed.push({
            item: userId,
            error: updateResult.error || new Error('Unknown error'),
          });
          continue;
        }
        
        result.successful.push(user);
      } catch (error) {
        this.logger.error('Batch update item failed', { userId, error });
        result.failed.push({
          item: userId,
          error: error instanceof Error ? error : new Error(String(error)),
        });
      }
    }
    
    this.logger.info('Batch update completed', {
      successful: result.successful.length,
      failed: result.failed.length,
    });
    
    return result;
  }
  
  /**
   * 古いファイルをクリーンアップする
   */
  cleanupOldFiles(paths: string[]): BatchResult<string> {
    this.logger.info('Cleaning up files', { count: paths.length });
    
    const result: BatchResult<string> = {
      successful: [],
      failed: [],
    };
    
    for (const path of paths) {
      const deleteResult = this.fileService.deleteFile(path);
      
      if (deleteResult.success) {
        result.successful.push(path);
      } else {
        result.failed.push({
          item: path,
          error: deleteResult.error || new Error('Unknown error'),
        });
      }
    }
    
    this.logger.info('Cleanup completed', {
      successful: result.successful.length,
      failed: result.failed.length,
    });
    
    return result;
  }
}

// 使用例
async function example() {
  const logger = new ConsoleLogger();
  const service = new UserDataService(logger);
  
  // エラーが適切にハンドリングされる
  const usersResult = service.loadUsersFromFile('/path/to/users.json');
  
  if (usersResult.success) {
    console.log('Users loaded:', usersResult.data);
  } else {
    console.error('Failed to load users:', usersResult.error);
  }
  
  // ネットワークエラーやファイルエラーが適切にハンドリングされる
  const syncResult = await service.syncUserData('123', '/path/to/user-123.json');
  
  if (syncResult.success) {
    console.log('User synced:', syncResult.data);
  } else {
    console.error('Failed to sync user:', syncResult.error);
  }
  
  // 一部が失敗しても全体が止まらない
  const batchResult = await service.batchUpdateUsers(['1', '2', '3', '4', '5']);
  
  console.log(`Successfully updated: ${batchResult.successful.length}`);
  console.log(`Failed to update: ${batchResult.failed.length}`);
  
  // 失敗したアイテムの詳細
  batchResult.failed.forEach(({ item, error }) => {
    console.error(`Failed to update user ${item}:`, error.message);
  });
}
```

## 改善のポイント

### 1. Result型による明示的なエラーハンドリング

```typescript
interface Result<T> {
  success: boolean;
  data?: T;
  error?: Error;
}
```

- エラーを戻り値として扱う
- 呼び出し側が必ずエラーチェックをする必要がある
- 型安全

### 2. カスタムエラークラス

```typescript
class FileError extends Error {
  constructor(message: string, public readonly path: string) {
    super(message);
    this.name = 'FileError';
  }
}
```

- エラーの種類を区別できる
- 追加情報を持たせられる
- `instanceof`で判定可能

### 3. 構造化ロギング

```typescript
this.logger.error('User fetch failed', { userId, error });
```

- エラーの文脈を記録
- デバッグが容易に
- 監視システムとの連携が可能

### 4. バッチ処理の失敗に強い実装

```typescript
interface BatchResult<T> {
  successful: T[];
  failed: Array<{ item: any; error: Error }>;
}
```

- 一部が失敗しても続行
- 成功・失敗の詳細を返す
- リトライや再処理が可能

## さらなる改善案

### リトライ処理

```typescript
async function withRetry<T>(
  fn: () => Promise<T>,
  options: {
    maxRetries: number;
    delay: number;
    shouldRetry?: (error: Error) => boolean;
  }
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      if (
        attempt === options.maxRetries ||
        (options.shouldRetry && !options.shouldRetry(lastError))
      ) {
        break;
      }
      
      await new Promise(resolve => setTimeout(resolve, options.delay));
    }
  }
  
  throw lastError!;
}

// 使用例
const result = await withRetry(
  () => apiService.fetchUser('123'),
  {
    maxRetries: 3,
    delay: 1000,
    shouldRetry: (error) => error instanceof NetworkError,
  }
);
```

### サーキットブレーカーパターン

```typescript
class CircuitBreaker {
  private failures = 0;
  private lastFailureTime?: number;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  
  constructor(
    private threshold: number,
    private timeout: number
  ) {}
  
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - (this.lastFailureTime || 0) > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new Error('Circuit breaker is OPEN');
      }
    }
    
    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failures = 0;
    this.state = 'CLOSED';
  }
  
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.threshold) {
      this.state = 'OPEN';
    }
  }
}
```

## 学んだこと

1. **エラーは必ず発生する前提で設計する**
   - Happy Pathだけでなく、エラーケースも考慮
   
2. **エラーの種類を区別する**
   - カスタムエラークラスで分類
   - 適切な対処が可能に

3. **ログの重要性**
   - エラーの文脈を記録
   - 問題の特定と修正が容易に

4. **部分的な失敗への対処**
   - バッチ処理は失敗に強く
   - 成功・失敗の詳細を記録

## エラーハンドリングチェックリスト

- [ ] すべての非同期処理にtry-catchがあるか？
- [ ] カスタムエラークラスを定義しているか？
- [ ] エラーをログに記録しているか？
- [ ] エラー情報に十分な文脈が含まれているか？
- [ ] バッチ処理は部分的な失敗に対応しているか？
- [ ] リトライが必要な処理を識別しているか？
