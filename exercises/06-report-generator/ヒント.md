# ヒント

## このコードの問題点

このコードには「参照の共有による意図しない副作用」というアンチパターンが含まれています。

### 具体的な問題

1. **オブジェクトの参照共有**
   - `const sub_dCriteria = dCriteria;` は新しいオブジェクトを作成していません
   - `sub_dCriteria`と`dCriteria`は同じオブジェクトを指しています
   - ループ内で`sub_dCriteria`を変更すると、元の`dCriteria`も変更されます

2. **意図しない状態の上書き**
   - ループの各反復で同じオブジェクトが更新されるため、最後のデータだけが残ります
   - すべてのループ処理が同じオブジェクトを操作しているため、履歴が残りません
   - 結果として、期待した動作になりません

3. **Map<string, any>の使用**
   - `any`型を使用しているため、型安全性が失われています
   - どのようなデータが格納されているか不明確です
   - TypeScriptの型システムの恩恵を受けられません

4. **セッターメソッドの濫用**
   - 10個以上のセッターメソッドを順番に呼び出しています
   - コンストラクタやファクトリーメソッドで一度に設定できます
   - 可読性が低く、設定漏れのリスクがあります

5. **手続き的すぎるコード**
   - データ変換処理が手続き的に書かれています
   - より宣言的な書き方ができます
   - 関数型プログラミングのアプローチが適用できます

## リファクタリングのアプローチ

### 1. オブジェクトのクローンまたは新規作成

JavaScriptのオブジェクトは参照型です。コピーする場合は明示的にクローンが必要です:

```typescript
// 問題のあるコード
const sub_dCriteria = dCriteria; // 参照のコピー（同じオブジェクト）

// 解決策1: スプレッド構文でシャローコピー
const sub_dCriteria = { ...dCriteria };

// 解決策2: ファクトリーメソッドで新規作成
const sub_dCriteria = DetailReportSearchCriteria.fromDataSource(sub_key);

// 解決策3: クローンメソッド
const sub_dCriteria = dCriteria.clone();
```

### 2. ファクトリーメソッドの導入

セッターの連続呼び出しの代わりに、データソースから直接オブジェクトを生成:

```typescript
class DetailReportSearchCriteria {
  static fromDataSource(
    source: ReportOutDataSource,
    includeAddress: boolean
  ): DetailReportSearchCriteria {
    const criteria = new DetailReportSearchCriteria();
    criteria.societyCode = source.uniqueID;
    criteria.memberDiv = source.memberDiv;
    criteria.toDistAss = source.toDistAss;
    // ... 他のフィールドも設定
    if (includeAddress) {
      criteria.addressDiv = source.addressDiv;
    }
    return criteria;
  }
}

// 使用例
const criteria = DetailReportSearchCriteria.fromDataSource(sub_key, true);
```

### 3. 型安全な結果オブジェクトの定義

`Map<string, any>`の代わりに、明示的な型を定義:

```typescript
interface ReportResult {
  index: number;
  societyCode: string;
  memberDiv: string;
}

const rs: ReportResult[] = [];
rs.push({
  index: i,
  societyCode: criteria.societyCode,
  memberDiv: criteria.memberDiv,
});
```

### 4. 関数型アプローチの適用

ループの代わりに`map`を使用:

```typescript
const rs = keyList.map((source, index) => {
  const criteria = DetailReportSearchCriteria.fromDataSource(source, true);
  
  return {
    index,
    societyCode: criteria.societyCode,
    memberDiv: criteria.memberDiv,
  };
});
```

### 5. イミュータブルなデータモデル

セッターを排除し、イミュータブルなオブジェクトに:

```typescript
class DetailReportSearchCriteria {
  constructor(
    readonly societyCode: string,
    readonly memberDiv: string,
    readonly toDistAss: string,
    // ... 他のフィールド
  ) {}

  // 変更が必要な場合は新しいインスタンスを返す
  withAddressDiv(addressDiv: string): DetailReportSearchCriteria {
    return new DetailReportSearchCriteria(
      this.societyCode,
      this.memberDiv,
      this.toDistAss,
      addressDiv,
      // ... 他のフィールド
    );
  }
}
```

## 考えてみましょう

1. なぜ`const sub_dCriteria = dCriteria`では新しいオブジェクトが作られないのでしょうか？
2. JavaScriptの参照型と値型の違いは何でしょうか？
3. セッターメソッドを多用するコードの問題点は何でしょうか？
4. `Map<string, any>`を使うことのデメリットは何でしょうか？
5. ループ処理をどのように関数型プログラミング的に書き換えられるでしょうか？
6. イミュータブルなデータ構造にするメリットは何でしょうか？

## 参考キーワード

- 参照型と値型 (Reference Types vs Value Types)
- シャローコピーとディープコピー (Shallow Copy vs Deep Copy)
- ファクトリーメソッドパターン (Factory Method Pattern)
- イミュータビリティ (Immutability)
- 関数型プログラミング (Functional Programming)
- データ変換 (Data Transformation)
- 型安全性 (Type Safety)
- Spread Operator（スプレッド構文）
- Object.assign
- structuredClone (JavaScript の新しいAPI)
