# 回答例

## リファクタリング後のコード

### 1. 型定義の整理

```typescript
interface ReportOutDataSource {
  uniqueID: string;
  memberDiv: string;
  toDistAss: string;
  toDistCode: string;
  directionDiv: string;
  addressDiv: string;
  taxationDiv: string;
  sourceDiv: string;
  dataDiv: string;
  performerFlg: boolean;
  taxRate: number;
  taxRate2: number;
}

interface ReportResult {
  index: number;
  societyCode: string;
  memberDiv: string;
  criteria: DetailReportSearchCriteria;
}
```

### 2. イミュータブルなCriteriaクラス（推奨）

```typescript
class DetailReportSearchCriteria {
  constructor(
    readonly societyCode: string = "",
    readonly memberDiv: string = "",
    readonly toDistAss: string = "",
    readonly toDistCode: string = "",
    readonly directionDiv: string = "",
    readonly addressDiv: string = "",
    readonly taxationDiv: string = "",
    readonly sourceDiv: string = "",
    readonly dataDiv: string = "",
    readonly performersFlag: boolean = false,
    readonly taxRate: number = 0,
    readonly taxRate2: number = 0
  ) {}

  static fromDataSource(
    source: ReportOutDataSource,
    includeAddress: boolean = true
  ): DetailReportSearchCriteria {
    return new DetailReportSearchCriteria(
      source.uniqueID,
      source.memberDiv,
      source.toDistAss,
      source.toDistCode,
      source.directionDiv,
      includeAddress ? source.addressDiv : "",
      source.taxationDiv,
      source.sourceDiv,
      source.dataDiv,
      source.performerFlg,
      source.taxRate,
      source.taxRate2
    );
  }

  clone(): DetailReportSearchCriteria {
    return new DetailReportSearchCriteria(
      this.societyCode,
      this.memberDiv,
      this.toDistAss,
      this.toDistCode,
      this.directionDiv,
      this.addressDiv,
      this.taxationDiv,
      this.sourceDiv,
      this.dataDiv,
      this.performersFlag,
      this.taxRate,
      this.taxRate2
    );
  }

  toResultMap(index: number): Map<string, any> {
    const map = new Map<string, any>();
    map.set("index", index);
    map.set("societyCode", this.societyCode);
    map.set("memberDiv", this.memberDiv);
    return map;
  }

  toObject() {
    return {
      societyCode: this.societyCode,
      memberDiv: this.memberDiv,
      toDistAss: this.toDistAss,
      toDistCode: this.toDistCode,
      directionDiv: this.directionDiv,
      addressDiv: this.addressDiv,
      taxationDiv: this.taxationDiv,
      sourceDiv: this.sourceDiv,
      dataDiv: this.dataDiv,
      performersFlag: this.performersFlag,
      taxRate: this.taxRate,
      taxRate2: this.taxRate2,
    };
  }
}
```

### 3. リファクタリング後の処理（基本版）

```typescript
function generateReports(keyList: ReportOutDataSource[]): ReportResult[] {
  const results: ReportResult[] = [];

  for (let i = 0; i < keyList.length; i++) {
    const source = keyList[i];
    
    // 毎回新しいインスタンスを作成
    const criteria = DetailReportSearchCriteria.fromDataSource(source, true);

    const result: ReportResult = {
      index: i,
      societyCode: criteria.societyCode,
      memberDiv: criteria.memberDiv,
      criteria: criteria,
    };

    results.push(result);

    console.log(`ループ${i + 1}回目:`, criteria.toObject());
  }

  return results;
}
```

### 4. 関数型アプローチ版（推奨）

```typescript
function generateReportsMap(
  keyList: ReportOutDataSource[]
): ReportResult[] {
  return keyList.map((source, index) => {
    const criteria = DetailReportSearchCriteria.fromDataSource(source, true);

    console.log(`ループ${index + 1}回目:`, criteria.toObject());

    return {
      index,
      societyCode: criteria.societyCode,
      memberDiv: criteria.memberDiv,
      criteria,
    };
  });
}
```

### 5. Map<string, any>を返す必要がある場合の互換版

```typescript
function generateReportsAsMap(
  keyList: ReportOutDataSource[]
): Array<Map<string, any>> {
  return keyList.map((source, index) => {
    const criteria = DetailReportSearchCriteria.fromDataSource(source, true);

    console.log(`ループ${index + 1}回目:`, criteria.toObject());

    return criteria.toResultMap(index);
  });
}
```

## より高度な実装

### 1. ビルダーパターンを使った実装

セッターを使いたい場合でも、より安全な実装が可能です:

```typescript
class DetailReportSearchCriteriaBuilder {
  private societyCode: string = "";
  private memberDiv: string = "";
  private toDistAss: string = "";
  private toDistCode: string = "";
  private directionDiv: string = "";
  private addressDiv: string = "";
  private taxationDiv: string = "";
  private sourceDiv: string = "";
  private dataDiv: string = "";
  private performersFlag: boolean = false;
  private taxRate: number = 0;
  private taxRate2: number = 0;

  setSocietyCode(v: string): this {
    this.societyCode = v;
    return this;
  }

  setMemberDiv(v: string): this {
    this.memberDiv = v;
    return this;
  }

  setToDistAss(v: string): this {
    this.toDistAss = v;
    return this;
  }

  setToDistCode(v: string): this {
    this.toDistCode = v;
    return this;
  }

  setDirectionDiv(v: string): this {
    this.directionDiv = v;
    return this;
  }

  setAddressDiv(v: string): this {
    this.addressDiv = v;
    return this;
  }

  setTaxationDiv(v: string): this {
    this.taxationDiv = v;
    return this;
  }

  setSourceDiv(v: string): this {
    this.sourceDiv = v;
    return this;
  }

  setDataDiv(v: string): this {
    this.dataDiv = v;
    return this;
  }

  setPerformersFlag(v: boolean): this {
    this.performersFlag = v;
    return this;
  }

  setTaxRate(v: number): this {
    this.taxRate = v;
    return this;
  }

  setTaxRate2(v: number): this {
    this.taxRate2 = v;
    return this;
  }

  fromDataSource(
    source: ReportOutDataSource,
    includeAddress: boolean = true
  ): this {
    this.societyCode = source.uniqueID;
    this.memberDiv = source.memberDiv;
    this.toDistAss = source.toDistAss;
    this.toDistCode = source.toDistCode;
    this.directionDiv = source.directionDiv;
    if (includeAddress) {
      this.addressDiv = source.addressDiv;
    }
    this.taxationDiv = source.taxationDiv;
    this.sourceDiv = source.sourceDiv;
    this.dataDiv = source.dataDiv;
    this.performersFlag = source.performerFlg;
    this.taxRate = source.taxRate;
    this.taxRate2 = source.taxRate2;
    return this;
  }

  build(): DetailReportSearchCriteria {
    return new DetailReportSearchCriteria(
      this.societyCode,
      this.memberDiv,
      this.toDistAss,
      this.toDistCode,
      this.directionDiv,
      this.addressDiv,
      this.taxationDiv,
      this.sourceDiv,
      this.dataDiv,
      this.performersFlag,
      this.taxRate,
      this.taxRate2
    );
  }
}

// 使用例
function generateReportsWithBuilder(
  keyList: ReportOutDataSource[]
): ReportResult[] {
  return keyList.map((source, index) => {
    const criteria = new DetailReportSearchCriteriaBuilder()
      .fromDataSource(source, true)
      .build();

    return {
      index,
      societyCode: criteria.societyCode,
      memberDiv: criteria.memberDiv,
      criteria,
    };
  });
}
```

### 2. データ変換用のマッパークラス

```typescript
class ReportDataMapper {
  static toSearchCriteria(
    source: ReportOutDataSource,
    options: { includeAddress?: boolean } = {}
  ): DetailReportSearchCriteria {
    const includeAddress = options.includeAddress ?? true;

    return new DetailReportSearchCriteria(
      source.uniqueID,
      source.memberDiv,
      source.toDistAss,
      source.toDistCode,
      source.directionDiv,
      includeAddress ? source.addressDiv : "",
      source.taxationDiv,
      source.sourceDiv,
      source.dataDiv,
      source.performerFlg,
      source.taxRate,
      source.taxRate2
    );
  }

  static toReportResult(
    criteria: DetailReportSearchCriteria,
    index: number
  ): ReportResult {
    return {
      index,
      societyCode: criteria.societyCode,
      memberDiv: criteria.memberDiv,
      criteria,
    };
  }

  static processReportData(
    sources: ReportOutDataSource[],
    options: { includeAddress?: boolean; logProgress?: boolean } = {}
  ): ReportResult[] {
    return sources.map((source, index) => {
      const criteria = this.toSearchCriteria(source, options);

      if (options.logProgress) {
        console.log(`ループ${index + 1}回目:`, criteria.toObject());
      }

      return this.toReportResult(criteria, index);
    });
  }
}

// 使用例
const results = ReportDataMapper.processReportData(testData, {
  includeAddress: true,
  logProgress: true,
});
```

### 3. 完全な実装例

```typescript
// テスト実行
const testData: ReportOutDataSource[] = [
  {
    uniqueID: "A001",
    memberDiv: "MD1",
    toDistAss: "ASS1",
    toDistCode: "C001",
    directionDiv: "DIR1",
    addressDiv: "Tokyo",
    taxationDiv: "TAX1",
    sourceDiv: "SRC1",
    dataDiv: "DATA1",
    performerFlg: true,
    taxRate: 10,
    taxRate2: 8,
  },
  {
    uniqueID: "B002",
    memberDiv: "MD2",
    toDistAss: "ASS2",
    toDistCode: "C002",
    directionDiv: "DIR2",
    addressDiv: "Osaka",
    taxationDiv: "TAX2",
    sourceDiv: "SRC2",
    dataDiv: "DATA2",
    performerFlg: false,
    taxRate: 5,
    taxRate2: 3,
  },
];

// 関数型アプローチでの実行
const results = generateReportsMap(testData);

console.log("結果リスト:");
results.forEach((result) => {
  console.log(`Index ${result.index}:`, {
    societyCode: result.societyCode,
    memberDiv: result.memberDiv,
  });
});

// 各結果が独立していることを確認
console.log("\n各criteriaは独立したインスタンス:");
console.log("Result 0:", results[0].criteria.toObject());
console.log("Result 1:", results[1].criteria.toObject());
```

## リファクタリングのポイント

### 1. 参照の共有問題の解決

**Before:**
```typescript
const sub_dCriteria = dCriteria; // 同じオブジェクトへの参照
sub_dCriteria.setSocietyCode("A001"); // 元のdCriteriaも変更される
```

**After:**
```typescript
// 毎回新しいインスタンスを作成
const criteria = DetailReportSearchCriteria.fromDataSource(source, true);
```

この変更により:
- 各ループで独立したオブジェクトが作成される
- 前のループの状態が次のループに影響しない
- 意図した通りの動作になる

### 2. セッターの連続呼び出しの改善

**Before:**
```typescript
sub_dCriteria.setSocietyCode(sub_key.uniqueID);
sub_dCriteria.setMemberDiv(sub_key.memberDiv);
sub_dCriteria.setToDistAss(sub_key.toDistAss);
// ... 10個以上のセッターメソッド
```

**After:**
```typescript
// ファクトリーメソッドで一度に設定
const criteria = DetailReportSearchCriteria.fromDataSource(source, true);
```

メリット:
- コードが簡潔になる
- 設定漏れが防げる
- データ変換ロジックが一箇所に集約される

### 3. 型安全性の向上

**Before:**
```typescript
const map = new Map<string, any>(); // any型を使用
map.set("index", i);
map.set("societyCode", sub_dCriteria.societyCode);
```

**After:**
```typescript
interface ReportResult {
  index: number;
  societyCode: string;
  memberDiv: string;
  criteria: DetailReportSearchCriteria;
}

const result: ReportResult = {
  index: i,
  societyCode: criteria.societyCode,
  memberDiv: criteria.memberDiv,
  criteria,
};
```

メリット:
- コンパイル時に型チェックが効く
- IDEの補完が効く
- ドキュメントとしても機能する

### 4. イミュータビリティの導入

**Before:**
```typescript
class DetailReportSearchCriteria {
  societyCode: string = "";
  
  setSocietyCode(v: string) {
    this.societyCode = v; // ミュータブル
  }
}
```

**After:**
```typescript
class DetailReportSearchCriteria {
  constructor(
    readonly societyCode: string = "", // イミュータブル
    // ...
  ) {}
}
```

メリット:
- オブジェクトの状態が予測可能
- 並行処理でも安全
- デバッグが容易

### 5. 関数型プログラミングの適用

**Before:**
```typescript
const rs: Array<Map<string, any>> = [];
for (let i = 0; i < keyList.length; i++) {
  // 処理
  rs.push(map);
}
```

**After:**
```typescript
const results = keyList.map((source, index) => {
  const criteria = DetailReportSearchCriteria.fromDataSource(source, true);
  return { index, societyCode: criteria.societyCode, ... };
});
```

メリット:
- 宣言的で読みやすい
- 副作用がない
- テストしやすい

## JavaScriptの参照型について

### 参照のコピーとオブジェクトのコピーの違い

```typescript
// 参照のコピー（問題のあるコード）
const obj1 = { name: "Alice" };
const obj2 = obj1; // 同じオブジェクトを指す
obj2.name = "Bob";
console.log(obj1.name); // "Bob" - obj1も変更される！

// オブジェクトのコピー（シャローコピー）
const obj3 = { name: "Alice" };
const obj4 = { ...obj3 }; // 新しいオブジェクトを作成
obj4.name = "Bob";
console.log(obj3.name); // "Alice" - obj3は変更されない

// ディープコピー（ネストしたオブジェクトも含む）
const obj5 = { name: "Alice", address: { city: "Tokyo" } };
const obj6 = structuredClone(obj5); // 完全なコピー
obj6.address.city = "Osaka";
console.log(obj5.address.city); // "Tokyo" - obj5は変更されない
```

## メリット

### 1. バグの防止

参照共有による意図しない副作用がなくなり、各ループで独立したデータが処理されます。

### 2. 可読性の向上

ファクトリーメソッドや`map`関数により、コードの意図が明確になります。

### 3. 保守性の向上

データ変換ロジックが一箇所に集約され、変更が容易になります。

### 4. テストの容易性

```typescript
describe("DetailReportSearchCriteria", () => {
  it("fromDataSourceで正しく変換される", () => {
    const source: ReportOutDataSource = {
      uniqueID: "TEST001",
      memberDiv: "MD1",
      // ...
    };

    const criteria = DetailReportSearchCriteria.fromDataSource(source, true);

    expect(criteria.societyCode).toBe("TEST001");
    expect(criteria.memberDiv).toBe("MD1");
  });

  it("各インスタンスが独立している", () => {
    const source1 = { uniqueID: "A001", /* ... */ };
    const source2 = { uniqueID: "B002", /* ... */ };

    const criteria1 = DetailReportSearchCriteria.fromDataSource(source1);
    const criteria2 = DetailReportSearchCriteria.fromDataSource(source2);

    expect(criteria1.societyCode).toBe("A001");
    expect(criteria2.societyCode).toBe("B002");
    // 互いに影響しない
  });
});
```

## まとめ

オブジェクトの参照共有による問題を解決することで:

1. **正確な動作**: 各ループで独立したデータが処理される
2. **予測可能性**: オブジェクトの状態が意図しない変更を受けない
3. **型安全性**: TypeScriptの型システムを最大限活用
4. **保守性**: データ変換ロジックが明確で変更しやすい
5. **テスト容易性**: 各コンポーネントを独立してテスト可能

特に「参照型」の理解はJavaScriptプログラミングの基礎であり、この問題を通じて深く学ぶことができます。
