# 回答例: 過剰なネスト

## リファクタリング後のコード

```typescript
interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
  category: string;
}

interface User {
  id: string;
  name: string;
  email: string;
  isPremium: boolean;
  address?: string;
}

interface OrderItem {
  productId: string;
  quantity: number;
}

/**
 * カスタムエラークラス
 */
class OrderError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'OrderError';
  }
}

class OrderProcessor {
  /**
   * 注文を処理する
   */
  processOrder(user: User, items: OrderItem[], products: Product[]): string {
    try {
      this.validateUser(user);
      this.validateOrderItems(items);
      
      const total = this.calculateTotal(items, products);
      const discountedTotal = this.applyDiscounts(total, user);
      
      this.validateAddress(user);
      
      return `注文が完了しました。合計金額: ${discountedTotal}円`;
    } catch (error) {
      if (error instanceof OrderError) {
        return error.message;
      }
      throw error;
    }
  }
  
  /**
   * ユーザー情報を検証する
   */
  private validateUser(user: User): void {
    if (!user) {
      throw new OrderError('ユーザー情報が見つかりません');
    }
    
    if (!user.email) {
      throw new OrderError('メールアドレスが登録されていません');
    }
  }
  
  /**
   * 注文商品を検証する
   */
  private validateOrderItems(items: OrderItem[]): void {
    if (!items || items.length === 0) {
      throw new OrderError('注文商品が指定されていません');
    }
  }
  
  /**
   * 配送先住所を検証する
   */
  private validateAddress(user: User): void {
    if (!user.address) {
      throw new OrderError('配送先住所が登録されていません');
    }
  }
  
  /**
   * 商品を検索する
   */
  private findProduct(productId: string, products: Product[]): Product {
    const product = products.find(p => p.id === productId);
    
    if (!product) {
      throw new OrderError(`商品ID「${productId}」が見つかりません`);
    }
    
    return product;
  }
  
  /**
   * 在庫を検証する
   */
  private validateStock(product: Product, quantity: number): void {
    if (product.stock < quantity) {
      throw new OrderError(`商品「${product.name}」の在庫が不足しています`);
    }
  }
  
  /**
   * 価格を検証する
   */
  private validatePrice(product: Product): void {
    if (product.price <= 0) {
      throw new OrderError(`商品「${product.name}」の価格が不正です`);
    }
  }
  
  /**
   * 合計金額を計算する
   */
  private calculateTotal(items: OrderItem[], products: Product[]): number {
    let total = 0;
    
    for (const item of items) {
      const product = this.findProduct(item.productId, products);
      this.validateStock(product, item.quantity);
      this.validatePrice(product);
      
      total += product.price * item.quantity;
    }
    
    if (total === 0) {
      throw new OrderError('合計金額が0円です');
    }
    
    return total;
  }
  
  /**
   * 割引を適用する
   */
  private applyDiscounts(total: number, user: User): number {
    let discountedTotal = total;
    
    // プレミアム会員割引
    if (user.isPremium) {
      discountedTotal *= 0.9;
    }
    
    // 大量購入割引
    if (total >= 10000) {
      discountedTotal *= 0.95;
    }
    
    return Math.floor(discountedTotal);
  }
}
```

## 改善のポイント

### 1. ガード節（Early Return）の活用

```typescript
// Before: ネストが深い
if (user) {
  if (user.email) {
    // 処理
  } else {
    return "エラー";
  }
} else {
  return "エラー";
}

// After: 早期リターンでネストを削減
if (!user) {
  throw new OrderError('エラー');
}
if (!user.email) {
  throw new OrderError('エラー');
}
// 処理
```

### 2. 関数の分割

- 元の1つの大きな関数を、8つの小さな関数に分割
- 各関数が単一の責務を持つ（Single Responsibility Principle）
- 関数名が処理内容を明確に表現

### 3. 例外を使ったエラーハンドリング

- カスタムエラークラス`OrderError`を定義
- `try-catch`で例外を一箇所でキャッチ
- エラーメッセージを統一的に扱える

### 4. 可読性の向上

- 最大ネストレベル: 7 → 2
- 1関数あたりの行数: 70行 → 最大15行程度
- コードの流れが上から下へ自然に読める

## さらなる改善案

### Result型を使ったエラーハンドリング

```typescript
type Result<T, E = Error> = 
  | { success: true; value: T }
  | { success: false; error: E };

class OrderProcessor {
  processOrder(
    user: User, 
    items: OrderItem[], 
    products: Product[]
  ): Result<string, OrderError> {
    const userValidation = this.validateUser(user);
    if (!userValidation.success) {
      return userValidation;
    }
    
    // 以降の処理...
    
    return {
      success: true,
      value: `注文が完了しました。合計金額: ${total}円`
    };
  }
  
  private validateUser(user: User): Result<void, OrderError> {
    if (!user) {
      return {
        success: false,
        error: new OrderError('ユーザー情報が見つかりません')
      };
    }
    
    return { success: true, value: undefined };
  }
}
```

### ビルダーパターンの活用

```typescript
class OrderValidationBuilder {
  private validators: Array<() => void> = [];
  
  addUserValidation(user: User): this {
    this.validators.push(() => {
      if (!user) throw new OrderError('ユーザー情報が見つかりません');
      if (!user.email) throw new OrderError('メールアドレスが登録されていません');
    });
    return this;
  }
  
  addItemsValidation(items: OrderItem[]): this {
    this.validators.push(() => {
      if (!items || items.length === 0) {
        throw new OrderError('注文商品が指定されていません');
      }
    });
    return this;
  }
  
  validate(): void {
    for (const validator of this.validators) {
      validator();
    }
  }
}

// 使用例
new OrderValidationBuilder()
  .addUserValidation(user)
  .addItemsValidation(items)
  .validate();
```

## 学んだこと

1. **ガード節で可読性が劇的に向上**
   - ネストを浅くすることで、コードの流れが理解しやすくなる
   
2. **関数分割の重要性**
   - 小さな関数は理解しやすく、テストしやすく、再利用しやすい
   
3. **例外処理の適切な使用**
   - 異常系を例外で扱うことで、正常系のコードがシンプルになる
   
4. **命名の重要性**
   - `validateUser()`, `calculateTotal()` など、関数名で処理内容が分かる

## ネスト削減のチェックリスト

- [ ] 条件を反転して早期リターンできないか？
- [ ] 複雑な処理を別関数に切り出せないか？
- [ ] 例外を使ってエラーハンドリングをまとめられないか？
- [ ] ループの中の処理を関数化できないか？
- [ ] 変数に意味のある名前を付けているか？
