# ヒント

## このコードの問題点

このコードには「極端に深いネスト（Deep Nesting）」というアンチパターンが含まれています。

### 具体的な問題

1. **ネストが10階層以上**
   - if文が何重にもネストされており、ロジックを追うのが非常に困難です
   - 条件分岐の組み合わせが複雑で、すべてのパターンを把握するのが難しいです

2. **認知的負荷が高い**
   - コードを読む際に、「今どの条件の中にいるのか」を常に覚えておく必要があります
   - インデントが深すぎて、コードの構造が見づらくなっています

3. **テストが困難**
   - すべての条件分岐の組み合わせをテストするのが大変です
   - 特定のパスをテストするために多くの条件を満たす必要があります

4. **重複コードが多い**
   - 似たような割引計算ロジックが何度も繰り返されています
   - 微妙に異なる条件で同じような処理が書かれています

5. **拡張性が低い**
   - 新しい顧客タイプや支払い方法を追加するのが困難です
   - 変更時にバグを混入させるリスクが高いです

## リファクタリングのアプローチ

### 1. ガード句を使った早期リターン

ネストを浅くする最も効果的な方法は、ガード句（Guard Clause）を使うことです:

```typescript
// Before: ネストが深い
if (条件A) {
  if (条件B) {
    // 処理
  }
}

// After: ガード句で早期リターン
if (!条件A) return エラー;
if (!条件B) return エラー;
// 処理
```

このパターンを使うと、異常系を先に処理して正常系のネストを浅くできます。

### 2. ポリモーフィズムの活用

顧客タイプごとに異なる計算ロジックは、ストラテジーパターンやポリモーフィズムで表現できます:

```typescript
interface DiscountStrategy {
  calculate(amount: number, paymentMethod: string): DiscountResult;
}

class RegularCustomerDiscount implements DiscountStrategy {
  calculate(amount: number, paymentMethod: string): DiscountResult {
    // 一般顧客の割引計算
  }
}

class PremiumCustomerDiscount implements DiscountStrategy {
  calculate(amount: number, paymentMethod: string): DiscountResult {
    // プレミアム顧客の割引計算
  }
}
```

### 3. ルックアップテーブル（マップ）の使用

固定的な条件と結果の組み合わせは、テーブルで表現できます:

```typescript
const DISCOUNT_RATES = {
  regular: {
    credit_card: { threshold: 10000, rate: 0.02 },
    bank_transfer: { threshold: 50000, rate: 0.01 },
  },
  premium: {
    credit_card: { threshold: 10000, rate: 0.05 },
    bank_transfer: { threshold: 50000, rate: 0.04 },
  },
  // ...
};
```

### 4. 責務の分離

1つのメソッドに複数の責務が混在しています。以下のように分離できます:

- **バリデーション**: 請求書と顧客の妥当性チェック
- **割引計算**: 顧客タイプと支払い方法に基づく割引率の決定
- **ポイント適用**: ロイヤルティポイントの適用
- **最終金額計算**: 割引を適用した最終金額の算出

### 5. 条件式の抽出

複雑な条件式は、わかりやすい名前のメソッドに抽出しましょう:

```typescript
// Before
if (customer.type === "premium" && customer.membershipLevel >= 3) {
  // ...
}

// After
if (this.isHighLevelPremiumCustomer(customer)) {
  // ...
}

private isHighLevelPremiumCustomer(customer: Customer): boolean {
  return customer.type === "premium" && customer.membershipLevel >= 3;
}
```

### 6. チェーン・オブ・レスポンシビリティパターン

複数の条件チェックは、責任の連鎖パターンで表現できます:

```typescript
interface PaymentHandler {
  handle(context: PaymentContext): PaymentResult | null;
  setNext(handler: PaymentHandler): PaymentHandler;
}

class AlreadyPaidHandler implements PaymentHandler {
  handle(context: PaymentContext): PaymentResult | null {
    if (context.invoice.status === "paid") {
      return { success: false, message: "既に支払い済みです" };
    }
    return null; // 次のハンドラーへ
  }
}
```

## 考えてみましょう

1. どの条件チェックを最初に行うべきでしょうか？（早期リターンの順序）
2. 顧客タイプごとの処理をどのように分離すべきでしょうか？
3. 割引率の計算ルールをどのようにデータ化できるでしょうか？
4. テストしやすい構造にするにはどうすればよいでしょうか？
5. 新しい顧客タイプや支払い方法を追加しやすい設計はどうすればよいでしょうか？

## 参考キーワード

- ガード句 (Guard Clause)
- 早期リターン (Early Return)
- ストラテジーパターン (Strategy Pattern)
- ポリモーフィズム (Polymorphism)
- ルックアップテーブル (Lookup Table)
- チェーン・オブ・レスポンシビリティパターン (Chain of Responsibility Pattern)
- 循環的複雑度 (Cyclomatic Complexity)
- フラットな制御構造 (Flat Control Structure)
