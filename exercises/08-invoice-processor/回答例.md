# 回答例

## リファクタリング後のコード

### 1. 型定義の整理

```typescript
interface Invoice {
  id: number;
  customerId: number;
  amount: number;
  items: InvoiceItem[];
  dueDate: string;
  status: "pending" | "paid" | "overdue";
}

interface InvoiceItem {
  productId: number;
  quantity: number;
  unitPrice: number;
}

interface Customer {
  id: number;
  name: string;
  type: "regular" | "premium" | "vip";
  membershipLevel: number;
  creditLimit: number;
  totalPurchases: number;
}

interface PaymentResult {
  success: boolean;
  finalAmount: number;
  discountApplied: number;
  message: string;
}

interface DiscountConfig {
  rate: number;
  threshold?: number;
}

interface PaymentContext {
  invoice: Invoice;
  customer: Customer;
  paymentMethod: string;
  useLoyaltyPoints: boolean;
  loyaltyPoints: number;
}
```

### 2. 割引設定のデータ化

```typescript
class DiscountRules {
  private static readonly REGULAR_DISCOUNTS: Record<
    string,
    DiscountConfig[]
  > = {
    credit_card: [
      { threshold: 10000, rate: 0.02 },
      { threshold: 0, rate: 0 },
    ],
    bank_transfer: [
      { threshold: 50000, rate: 0.01 },
      { threshold: 0, rate: 0 },
    ],
    default: [{ threshold: 0, rate: 0 }],
  };

  private static readonly PREMIUM_HIGH_LEVEL_DISCOUNTS: Record<
    string,
    DiscountConfig[]
  > = {
    credit_card: [
      { threshold: 10000, rate: 0.05 },
      { threshold: 0, rate: 0.03 },
    ],
    bank_transfer: [
      { threshold: 50000, rate: 0.04 },
      { threshold: 0, rate: 0.02 },
    ],
    default: [{ threshold: 0, rate: 0.01 }],
  };

  private static readonly PREMIUM_STANDARD_DISCOUNTS: Record<
    string,
    DiscountConfig[]
  > = {
    credit_card: [{ threshold: 0, rate: 0.03 }],
    default: [{ threshold: 0, rate: 0.01 }],
  };

  private static readonly VIP_ELITE_DISCOUNTS: Record<
    string,
    DiscountConfig[]
  > = {
    credit_card: [
      { threshold: 10000, rate: 0.1 },
      { threshold: 0, rate: 0.07 },
    ],
    bank_transfer: [{ threshold: 0, rate: 0.08 }],
    default: [{ threshold: 0, rate: 0.05 }],
  };

  private static readonly VIP_STANDARD_DISCOUNTS: Record<
    string,
    DiscountConfig[]
  > = {
    credit_card: [{ threshold: 0, rate: 0.07 }],
    default: [{ threshold: 0, rate: 0.05 }],
  };

  static getDiscountConfig(
    customerType: string,
    membershipLevel: number,
    totalPurchases: number,
    paymentMethod: string
  ): DiscountConfig[] {
    if (customerType === "regular") {
      return this.REGULAR_DISCOUNTS[paymentMethod] || this.REGULAR_DISCOUNTS.default;
    }

    if (customerType === "premium") {
      if (membershipLevel >= 3) {
        return (
          this.PREMIUM_HIGH_LEVEL_DISCOUNTS[paymentMethod] ||
          this.PREMIUM_HIGH_LEVEL_DISCOUNTS.default
        );
      }
      return (
        this.PREMIUM_STANDARD_DISCOUNTS[paymentMethod] ||
        this.PREMIUM_STANDARD_DISCOUNTS.default
      );
    }

    if (customerType === "vip") {
      if (totalPurchases >= 1000000) {
        return (
          this.VIP_ELITE_DISCOUNTS[paymentMethod] ||
          this.VIP_ELITE_DISCOUNTS.default
        );
      }
      return (
        this.VIP_STANDARD_DISCOUNTS[paymentMethod] ||
        this.VIP_STANDARD_DISCOUNTS.default
      );
    }

    return [{ threshold: 0, rate: 0 }];
  }
}
```

### 3. バリデーター

```typescript
class PaymentValidator {
  validate(context: PaymentContext): PaymentResult | null {
    // ガード句: 既に支払い済み
    if (context.invoice.status === "paid") {
      return this.createFailureResult("この請求書は既に支払い済みです");
    }

    // ガード句: クレジット限度額チェック
    const creditLimitError = this.validateCreditLimit(
      context.invoice.amount,
      context.customer
    );
    if (creditLimitError) {
      return creditLimitError;
    }

    // ガード句: 無効な顧客タイプ
    if (!this.isValidCustomerType(context.customer.type)) {
      return this.createFailureResult("不正な顧客タイプです");
    }

    return null; // バリデーション成功
  }

  private validateCreditLimit(
    amount: number,
    customer: Customer
  ): PaymentResult | null {
    const effectiveCreditLimit = this.getEffectiveCreditLimit(customer);

    if (amount > effectiveCreditLimit) {
      return this.createFailureResult("クレジット限度額を超えています");
    }

    return null;
  }

  private getEffectiveCreditLimit(customer: Customer): number {
    if (customer.type === "premium") {
      return customer.creditLimit * 1.5;
    }
    if (customer.type === "vip") {
      return Number.MAX_SAFE_INTEGER; // VIPは実質無制限
    }
    return customer.creditLimit;
  }

  private isValidCustomerType(type: string): boolean {
    return ["regular", "premium", "vip"].includes(type);
  }

  private createFailureResult(message: string): PaymentResult {
    return {
      success: false,
      finalAmount: 0,
      discountApplied: 0,
      message,
    };
  }
}
```

### 4. 割引計算サービス

```typescript
class DiscountCalculator {
  calculateDiscount(
    amount: number,
    customer: Customer,
    paymentMethod: string
  ): { discountAmount: number; message: string } {
    const discountConfigs = DiscountRules.getDiscountConfig(
      customer.type,
      customer.membershipLevel,
      customer.totalPurchases,
      paymentMethod
    );

    // 金額に応じた割引率を選択
    for (const config of discountConfigs) {
      if (!config.threshold || amount >= config.threshold) {
        const discountAmount = amount * config.rate;
        const percentage = (config.rate * 100).toFixed(0);
        const message =
          config.rate > 0 ? `${percentage}%割引が適用されました` : "割引なし";

        return { discountAmount, message };
      }
    }

    return { discountAmount: 0, message: "割引なし" };
  }
}
```

### 5. ロイヤルティポイント適用サービス

```typescript
class LoyaltyPointService {
  applyPoints(
    currentAmount: number,
    useLoyaltyPoints: boolean,
    availablePoints: number,
    customer: Customer
  ): { finalAmount: number; pointsUsed: number } {
    // ポイント使用不可の条件
    if (!useLoyaltyPoints || availablePoints <= 0) {
      return { finalAmount: currentAmount, pointsUsed: 0 };
    }

    // ポイント使用可能な顧客タイプかチェック
    if (!this.canUsePoints(customer)) {
      return { finalAmount: currentAmount, pointsUsed: 0 };
    }

    // ポイント適用
    const pointsUsed = Math.min(availablePoints, currentAmount);
    const finalAmount = currentAmount - pointsUsed;

    return { finalAmount, pointsUsed };
  }

  private canUsePoints(customer: Customer): boolean {
    // プレミアム顧客（レベル3以上）とVIP顧客のみポイント使用可能
    if (customer.type === "premium" && customer.membershipLevel >= 3) {
      return true;
    }
    if (customer.type === "vip") {
      return true;
    }
    return false;
  }
}
```

### 6. リファクタリング後のInvoiceProcessor

```typescript
class InvoiceProcessor {
  private validator: PaymentValidator;
  private discountCalculator: DiscountCalculator;
  private loyaltyPointService: LoyaltyPointService;

  constructor() {
    this.validator = new PaymentValidator();
    this.discountCalculator = new DiscountCalculator();
    this.loyaltyPointService = new LoyaltyPointService();
  }

  calculateFinalAmount(
    invoice: Invoice,
    customer: Customer,
    paymentMethod: string,
    useLoyaltyPoints: boolean,
    loyaltyPoints: number
  ): PaymentResult {
    const context: PaymentContext = {
      invoice,
      customer,
      paymentMethod,
      useLoyaltyPoints,
      loyaltyPoints,
    };

    // 1. バリデーション（ガード句で早期リターン）
    const validationError = this.validator.validate(context);
    if (validationError) {
      return validationError;
    }

    // 2. 割引計算
    const { discountAmount, message: discountMessage } =
      this.discountCalculator.calculateDiscount(
        invoice.amount,
        customer,
        paymentMethod
      );

    const amountAfterDiscount = invoice.amount - discountAmount;

    // 3. ポイント適用
    const { finalAmount, pointsUsed } = this.loyaltyPointService.applyPoints(
      amountAfterDiscount,
      useLoyaltyPoints,
      loyaltyPoints,
      customer
    );

    // 4. 結果メッセージの生成
    const message = this.generateMessage(
      discountMessage,
      pointsUsed,
      discountAmount
    );

    return {
      success: true,
      finalAmount,
      discountApplied: discountAmount + pointsUsed,
      message,
    };
  }

  private generateMessage(
    discountMessage: string,
    pointsUsed: number,
    discountAmount: number
  ): string {
    if (pointsUsed > 0 && discountAmount > 0) {
      return discountMessage.replace(
        "が適用されました",
        "とポイント割引が適用されました"
      );
    }
    return discountMessage;
  }
}
```

## より柔軟な実装（ストラテジーパターン版）

さらに拡張性を高めたい場合は、ストラテジーパターンを使った実装も可能です。

### 1. 割引ストラテジーインターフェース

```typescript
interface DiscountStrategy {
  calculateDiscount(
    amount: number,
    paymentMethod: string,
    membershipLevel?: number,
    totalPurchases?: number
  ): { discountAmount: number; message: string };
  canUsePoints(): boolean;
}
```

### 2. 顧客タイプ別のストラテジー実装

```typescript
class RegularCustomerStrategy implements DiscountStrategy {
  calculateDiscount(
    amount: number,
    paymentMethod: string
  ): { discountAmount: number; message: string } {
    if (paymentMethod === "credit_card" && amount >= 10000) {
      return {
        discountAmount: amount * 0.02,
        message: "2%割引が適用されました",
      };
    }
    if (paymentMethod === "bank_transfer" && amount >= 50000) {
      return {
        discountAmount: amount * 0.01,
        message: "1%割引が適用されました",
      };
    }
    return { discountAmount: 0, message: "割引なし" };
  }

  canUsePoints(): boolean {
    return false;
  }
}

class PremiumCustomerStrategy implements DiscountStrategy {
  calculateDiscount(
    amount: number,
    paymentMethod: string,
    membershipLevel: number = 0
  ): { discountAmount: number; message: string } {
    const isHighLevel = membershipLevel >= 3;

    if (paymentMethod === "credit_card") {
      if (isHighLevel) {
        const rate = amount >= 10000 ? 0.05 : 0.03;
        return {
          discountAmount: amount * rate,
          message: `${rate * 100}%割引が適用されました`,
        };
      }
      return {
        discountAmount: amount * 0.03,
        message: "3%割引が適用されました",
      };
    }

    if (paymentMethod === "bank_transfer" && isHighLevel) {
      const rate = amount >= 50000 ? 0.04 : 0.02;
      return {
        discountAmount: amount * rate,
        message: `${rate * 100}%割引が適用されました`,
      };
    }

    return {
      discountAmount: amount * 0.01,
      message: "1%割引が適用されました",
    };
  }

  canUsePoints(): boolean {
    return true; // membershipLevel >= 3 の場合のみ、呼び出し側で制御
  }
}

class VipCustomerStrategy implements DiscountStrategy {
  calculateDiscount(
    amount: number,
    paymentMethod: string,
    membershipLevel: number = 0,
    totalPurchases: number = 0
  ): { discountAmount: number; message: string } {
    const isElite = totalPurchases >= 1000000;

    if (paymentMethod === "credit_card") {
      let rate: number;
      if (isElite) {
        rate = amount >= 10000 ? 0.1 : 0.07;
      } else {
        rate = 0.07;
      }
      return {
        discountAmount: amount * rate,
        message: `${rate * 100}%割引が適用されました`,
      };
    }

    if (paymentMethod === "bank_transfer" && isElite) {
      return {
        discountAmount: amount * 0.08,
        message: "8%割引が適用されました",
      };
    }

    return {
      discountAmount: amount * 0.05,
      message: "5%割引が適用されました",
    };
  }

  canUsePoints(): boolean {
    return true;
  }
}
```

### 3. ストラテジーファクトリー

```typescript
class DiscountStrategyFactory {
  static getStrategy(customer: Customer): DiscountStrategy {
    switch (customer.type) {
      case "regular":
        return new RegularCustomerStrategy();
      case "premium":
        return new PremiumCustomerStrategy();
      case "vip":
        return new VipCustomerStrategy();
      default:
        throw new Error(`Unknown customer type: ${customer.type}`);
    }
  }
}
```

### 4. ストラテジーパターンを使用したInvoiceProcessor

```typescript
class InvoiceProcessorWithStrategy {
  private validator: PaymentValidator;
  private loyaltyPointService: LoyaltyPointService;

  constructor() {
    this.validator = new PaymentValidator();
    this.loyaltyPointService = new LoyaltyPointService();
  }

  calculateFinalAmount(
    invoice: Invoice,
    customer: Customer,
    paymentMethod: string,
    useLoyaltyPoints: boolean,
    loyaltyPoints: number
  ): PaymentResult {
    const context: PaymentContext = {
      invoice,
      customer,
      paymentMethod,
      useLoyaltyPoints,
      loyaltyPoints,
    };

    // バリデーション
    const validationError = this.validator.validate(context);
    if (validationError) {
      return validationError;
    }

    // 顧客タイプに応じたストラテジーを取得
    const strategy = DiscountStrategyFactory.getStrategy(customer);

    // 割引計算
    const { discountAmount, message: discountMessage } =
      strategy.calculateDiscount(
        invoice.amount,
        paymentMethod,
        customer.membershipLevel,
        customer.totalPurchases
      );

    const amountAfterDiscount = invoice.amount - discountAmount;

    // ポイント適用
    const { finalAmount, pointsUsed } = this.loyaltyPointService.applyPoints(
      amountAfterDiscount,
      useLoyaltyPoints && strategy.canUsePoints(),
      loyaltyPoints,
      customer
    );

    // メッセージ生成
    const message =
      pointsUsed > 0 && discountAmount > 0
        ? discountMessage.replace(
            "が適用されました",
            "とポイント割引が適用されました"
          )
        : discountMessage;

    return {
      success: true,
      finalAmount,
      discountApplied: discountAmount + pointsUsed,
      message,
    };
  }
}
```

## リファクタリングのポイント

### 1. ガード句による早期リターン

元のコードでは、正常系の処理が深いネストの中に埋もれていました。ガード句を使って異常系を先に処理することで、ネストを大幅に削減しました。

**Before:**
```typescript
if (invoice.status === "paid") {
  return error;
} else {
  if (customer.type === "regular") {
    if (amount > limit) {
      return error;
    } else {
      // 深くネストした正常系処理
    }
  }
}
```

**After:**
```typescript
if (invoice.status === "paid") return error;
if (amount > limit) return error;
// フラットな正常系処理
```

### 2. データ駆動設計

複雑な条件分岐をデータ構造で表現することで、コードの見通しが良くなりました:

- 割引率のルールをオブジェクトとして定義
- 条件に応じた設定を検索する形式に変更
- 新しいルール追加時は設定を追加するだけ

### 3. 責務の分離

元の1つの巨大なメソッドを、以下のように責務ごとに分離:

- `PaymentValidator`: バリデーション専門
- `DiscountCalculator`: 割引計算専門
- `LoyaltyPointService`: ポイント処理専門
- `InvoiceProcessor`: 全体の調整役

### 4. ポリモーフィズムの活用（ストラテジーパターン版）

顧客タイプごとの異なる振る舞いを、インターフェースとクラスで表現:

- 各顧客タイプが独立したクラスになり、変更の影響が局所化
- 新しい顧客タイプの追加が容易
- 各クラスが単一責任の原則に従う

## メリット

### 1. 可読性の向上

- ネストが浅く、コードの流れが追いやすい
- 各メソッドが何をしているか一目瞭然
- インデントが少なく、画面に収まりやすい

### 2. テストの容易性

```typescript
describe("DiscountCalculator", () => {
  it("プレミアム顧客が10,000円以上をクレジットカードで支払う場合、5%割引", () => {
    const calculator = new DiscountCalculator();
    const customer: Customer = {
      type: "premium",
      membershipLevel: 3,
      // ...
    };
    const result = calculator.calculateDiscount(10000, customer, "credit_card");
    expect(result.discountAmount).toBe(500);
  });
});
```

各コンポーネントを独立してテストできます。

### 3. 保守性の向上

- 割引ルールの変更 → `DiscountRules`のデータを変更
- バリデーションロジックの追加 → `PaymentValidator`に追加
- 新しい顧客タイプ → 新しいストラテジークラスを作成

変更の影響範囲が明確で、バグ混入のリスクが低減します。

### 4. 拡張性の向上

新しい機能を追加しやすい構造になりました:

- 新しい支払い方法の追加 → `DiscountRules`に設定追加
- 新しい顧客タイプ → 新しいストラテジー実装を追加
- 新しい割引ルール → データ構造を拡張

## まとめ

深いネストを解消することで:

1. **コードが読みやすくなる**: フラットな構造で流れが明確
2. **テストが書きやすくなる**: 各部分を独立してテスト可能
3. **変更に強くなる**: 影響範囲が限定され、安全に変更できる
4. **拡張しやすくなる**: 新しい要件に柔軟に対応できる
5. **バグが減る**: シンプルな構造で理解しやすく、ミスが減る

「ネストは3段階まで」というルールを意識し、それを超える場合は設計を見直すことで、保守性の高いコードを維持できます。
