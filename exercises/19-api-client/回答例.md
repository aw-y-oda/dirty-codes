# 回答例: TypeScriptの型を活用できていない（anyの乱用）

## リファクタリング後のコード

```typescript
/**
 * APIレスポンスの型定義
 */
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

/**
 * APIエラーの型定義
 */
interface ApiError {
  status: number;
  message: string;
  errors?: Record<string, string[]>;
}

/**
 * ユーザーの型定義
 */
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
  createdAt: string;
  updatedAt: string;
}

/**
 * ユーザー作成時の入力データ型
 */
type CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

/**
 * ユーザー更新時の入力データ型
 */
type UpdateUserInput = Partial<CreateUserInput>;

/**
 * 商品の型定義
 */
interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
  category: string;
  description: string;
}

/**
 * 商品検索フィルターの型定義
 */
interface ProductFilters {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  inStock?: boolean;
  search?: string;
}

/**
 * 商品一覧のレスポンス型
 */
interface ProductListResponse {
  products: Product[];
  total: number;
  page: number;
  pageSize: number;
}

/**
 * 型安全なAPIクライアント
 */
class ApiClient {
  private baseUrl: string;
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl;
  }
  
  /**
   * GETリクエスト
   */
  async get<T>(endpoint: string): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`);
    
    if (!response.ok) {
      throw await this.handleError(response);
    }
    
    return response.json() as Promise<T>;
  }
  
  /**
   * POSTリクエスト
   */
  async post<TRequest, TResponse>(
    endpoint: string,
    body: TRequest
  ): Promise<TResponse> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });
    
    if (!response.ok) {
      throw await this.handleError(response);
    }
    
    return response.json() as Promise<TResponse>;
  }
  
  /**
   * エラーハンドリング
   */
  private async handleError(response: Response): Promise<ApiError> {
    const error: ApiError = {
      status: response.status,
      message: response.statusText,
    };
    
    try {
      const errorData = await response.json();
      error.message = errorData.message || error.message;
      error.errors = errorData.errors;
    } catch {
      // JSON解析に失敗した場合はデフォルトのエラーメッセージを使用
    }
    
    return error;
  }
}

/**
 * ユーザーサービス
 */
class UserService {
  private apiClient: ApiClient;
  
  constructor(apiClient: ApiClient) {
    this.apiClient = apiClient;
  }
  
  /**
   * ユーザーを取得
   */
  async getUser(userId: string): Promise<User> {
    return this.apiClient.get<User>(`/users/${userId}`);
  }
  
  /**
   * ユーザーを作成
   */
  async createUser(userData: CreateUserInput): Promise<User> {
    return this.apiClient.post<CreateUserInput, User>('/users', userData);
  }
  
  /**
   * ユーザーを更新
   */
  async updateUser(userId: string, userData: UpdateUserInput): Promise<User> {
    return this.apiClient.post<UpdateUserInput, User>(
      `/users/${userId}`,
      userData
    );
  }
}

/**
 * 商品サービス
 */
class ProductService {
  private apiClient: ApiClient;
  
  constructor(apiClient: ApiClient) {
    this.apiClient = apiClient;
  }
  
  /**
   * 商品を取得
   */
  async getProduct(productId: string): Promise<Product> {
    return this.apiClient.get<Product>(`/products/${productId}`);
  }
  
  /**
   * 商品一覧を取得
   */
  async listProducts(filters: ProductFilters = {}): Promise<ProductListResponse> {
    const query = this.buildQueryString(filters);
    return this.apiClient.get<ProductListResponse>(`/products?${query}`);
  }
  
  /**
   * クエリ文字列を構築
   */
  private buildQueryString(filters: ProductFilters): string {
    const params = new URLSearchParams();
    
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        params.append(key, String(value));
      }
    });
    
    return params.toString();
  }
}

// 使用例（型安全）
async function example() {
  const apiClient = new ApiClient('https://api.example.com');
  const userService = new UserService(apiClient);
  
  // 型補完が効く
  const user = await userService.getUser('123');
  console.log(user.name); // OK
  // console.log(user.emai); // コンパイルエラー！
  
  // 不正な型を渡すとエラー
  await userService.createUser({
    name: 'John',
    email: 'john@example.com',
    age: 30, // 数値でないとエラー
    // invalid: 'field', // コンパイルエラー！
  });
  
  // Partial型により、一部のフィールドのみ更新可能
  await userService.updateUser('123', {
    name: 'John Updated', // OK
    // id: '456', // id は含まれていないのでエラー
  });
}
```

## 改善のポイント

### 1. ジェネリクスによる型安全性

```typescript
async get<T>(endpoint: string): Promise<T>
```

- メソッド呼び出し時に具体的な型を指定
- 戻り値の型が保証される
- IDEの補完が効く

### 2. Utility Typesの活用

```typescript
type CreateUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;
type UpdateUserInput = Partial<CreateUserInput>;
```

- `Omit`: 不要なプロパティを除外
- `Partial`: 全てのプロパティをオプショナルに
- 型の再利用と保守性の向上

### 3. 明確なインターフェース定義

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
  createdAt: string;
  updatedAt: string;
}
```

- APIレスポンスの構造が明確
- ドキュメントの役割も果たす
- リファクタリングが安全に

### 4. エラーハンドリングの型定義

```typescript
interface ApiError {
  status: number;
  message: string;
  errors?: Record<string, string[]>;
}
```

- エラーの構造も型安全に
- エラーハンドリングが統一される

## さらなる改善案

### Zodによる実行時型検証

```typescript
import { z } from 'zod';

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  age: z.number().min(0).max(150),
  createdAt: z.string(),
  updatedAt: z.string(),
});

type User = z.infer<typeof UserSchema>;

class ApiClient {
  async get<T>(endpoint: string, schema: z.ZodType<T>): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`);
    const data = await response.json();
    
    // 実行時に型検証
    return schema.parse(data);
  }
}

// 使用例
const user = await apiClient.get('/users/123', UserSchema);
```

### Discriminated Unionによるエラーハンドリング

```typescript
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

class ApiClient {
  async get<T>(endpoint: string): Promise<Result<T, ApiError>> {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`);
      
      if (!response.ok) {
        return {
          success: false,
          error: await this.handleError(response),
        };
      }
      
      return {
        success: true,
        data: await response.json(),
      };
    } catch (error) {
      return {
        success: false,
        error: {
          status: 0,
          message: error instanceof Error ? error.message : 'Unknown error',
        },
      };
    }
  }
}

// 使用例
const result = await apiClient.get<User>('/users/123');

if (result.success) {
  console.log(result.data.name); // 型安全にアクセス
} else {
  console.error(result.error.message);
}
```

### 型ガードの実装

```typescript
function isUser(value: unknown): value is User {
  if (typeof value !== 'object' || value === null) {
    return false;
  }
  
  const obj = value as Record<string, unknown>;
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.email === 'string' &&
    typeof obj.age === 'number' &&
    typeof obj.createdAt === 'string' &&
    typeof obj.updatedAt === 'string'
  );
}

// 使用例
const data: unknown = await response.json();

if (isUser(data)) {
  // この中では data は User 型として扱える
  console.log(data.name);
}
```

## 学んだこと

1. **anyは最後の手段**
   - どうしても型が付けられない場合のみ使用
   - できる限り`unknown`を使い、型ガードで絞り込む

2. **ジェネリクスの威力**
   - 型の再利用性と安全性を両立
   - メソッドレベルで柔軟に型を指定できる

3. **Utility Typesの活用**
   - TypeScript標準の型変換ユーティリティを活用
   - コード量を減らしつつ型安全性を保つ

4. **実行時検証の重要性**
   - 外部からのデータは信用しない
   - Zodなどのライブラリで実行時にも検証

## 型安全性チェックリスト

- [ ] `any`を使っていないか？
- [ ] API レスポンスに型定義があるか？
- [ ] ジェネリクスで型を保持しているか？
- [ ] Utility Types を活用できているか？
- [ ] エラーハンドリングも型安全か？
- [ ] 実行時の型検証は必要ないか？
