# ヒント: 汎用的な型を異なる概念で共有してしまう

## 問題点

このコードには以下の問題があります：

1. **型の意味が曖昧**
   - `IdAndName`は商品なのか、カテゴリーなのか、ユーザーなのか分からない
   - `EntityWithTimestamp`は注文なのか、配送なのか、請求書なのか分からない

2. **型安全性の欠如**
   - 商品を期待する関数にカテゴリーを渡してもエラーにならない
   - 注文を期待する関数に配送を渡してもエラーにならない
   - コンパイル時にバグを検出できない

3. **ドメインモデルの表現不足**
   - ビジネスロジックにおける概念の違いが型に反映されていない
   - コードからビジネスルールが読み取りにくい

4. **拡張性の低さ**
   - 商品固有のプロパティを追加したい場合、他の概念に影響する
   - 概念ごとに異なるバリデーションを適用できない

## 改善のポイント

### 1. 概念ごとに型を定義

```typescript
type Product = {
  id: string;
  name: string;
  // 商品固有のプロパティ
};

type Category = {
  id: string;
  name: string;
  // カテゴリー固有のプロパティ
};
```

たとえ構造が同じでも、異なる概念であれば別の型として定義する。

### 2. Branded Type（名目的型付け）

```typescript
type ProductId = string & { readonly brand: unique symbol };
type CategoryId = string & { readonly brand: unique symbol };
```

プリミティブ型に意味を持たせる。

### 3. Nominal Typing のシミュレーション

```typescript
class Product {
  private readonly _brand!: 'Product';
  constructor(
    public readonly id: string,
    public readonly name: string
  ) {}
}
```

クラスを使用して名目的型付けを実現。

### 4. 共通プロパティの抽出

```typescript
interface Identifiable {
  id: string;
}

interface Product extends Identifiable {
  name: string;
  price: number;
}
```

本当に共通化すべきものだけを抽出。

## 考えてみよう

- どの概念を別の型として定義すべきですか？
- 本当に共通化すべきプロパティは何ですか？
- Branded Typeをどう活用できますか？
- ジェネリクスで共通ロジックを再利用できますか？
