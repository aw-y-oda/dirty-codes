# 回答例: 汎用的な型を異なる概念で共有してしまう

## リファクタリング後のコード

```typescript
/**
 * Branded Type の定義
 * プリミティブ型に意味を持たせる
 */
type Brand<K, T> = K & { __brand: T };

type ProductId = Brand<string, 'ProductId'>;
type CategoryId = Brand<string, 'CategoryId'>;
type OrderId = Brand<string, 'OrderId'>;
type ShipmentId = Brand<string, 'ShipmentId'>;
type InvoiceId = Brand<string, 'InvoiceId'>;

/**
 * Branded Type のファクトリー関数
 */
function createProductId(id: string): ProductId {
  return id as ProductId;
}

function createCategoryId(id: string): CategoryId {
  return id as CategoryId;
}

function createOrderId(id: string): OrderId {
  return id as OrderId;
}

function createShipmentId(id: string): ShipmentId {
  return id as ShipmentId;
}

function createInvoiceId(id: string): InvoiceId {
  return id as InvoiceId;
}

/**
 * ドメインモデルの型定義
 */
interface Product {
  id: ProductId;
  name: string;
  price: number;
  stock: number;
  categoryId: CategoryId;
}

interface Category {
  id: CategoryId;
  name: string;
  description: string;
  parentCategoryId?: CategoryId;
}

interface Order {
  id: OrderId;
  userId: string;
  items: OrderItem[];
  totalAmount: number;
  status: OrderStatus;
  createdAt: Date;
  updatedAt: Date;
}

interface OrderItem {
  productId: ProductId;
  quantity: number;
  price: number;
}

enum OrderStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  SHIPPED = 'SHIPPED',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED',
}

interface Shipment {
  id: ShipmentId;
  orderId: OrderId;
  trackingNumber: string;
  carrier: string;
  status: ShipmentStatus;
  shippedAt?: Date;
  deliveredAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

enum ShipmentStatus {
  PREPARING = 'PREPARING',
  SHIPPED = 'SHIPPED',
  IN_TRANSIT = 'IN_TRANSIT',
  DELIVERED = 'DELIVERED',
  FAILED = 'FAILED',
}

interface Invoice {
  id: InvoiceId;
  orderId: OrderId;
  invoiceNumber: string;
  amount: number;
  taxAmount: number;
  totalAmount: number;
  status: InvoiceStatus;
  issuedAt: Date;
  dueAt: Date;
  paidAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

enum InvoiceStatus {
  DRAFT = 'DRAFT',
  ISSUED = 'ISSUED',
  PAID = 'PAID',
  OVERDUE = 'OVERDUE',
  CANCELLED = 'CANCELLED',
}

/**
 * 商品サービス
 */
class ProductService {
  getProduct(id: ProductId): Product {
    return {
      id,
      name: 'Laptop',
      price: 1500,
      stock: 10,
      categoryId: createCategoryId('electronics'),
    };
  }
  
  getCategory(id: CategoryId): Category {
    return {
      id,
      name: 'Electronics',
      description: 'Electronic devices and accessories',
    };
  }
  
  // 商品専用の表示関数
  displayProduct(product: Product): void {
    console.log(`Product: ${product.name} (¥${product.price})`);
    console.log(`Stock: ${product.stock}`);
  }
  
  // カテゴリー専用の表示関数
  displayCategory(category: Category): void {
    console.log(`Category: ${category.name}`);
    console.log(`Description: ${category.description}`);
  }
}

/**
 * 注文サービス
 */
class OrderService {
  getOrder(id: OrderId): Order {
    return {
      id,
      userId: 'user-123',
      items: [
        {
          productId: createProductId('product-1'),
          quantity: 2,
          price: 1500,
        },
      ],
      totalAmount: 3000,
      status: OrderStatus.CONFIRMED,
      createdAt: new Date('2025-01-01'),
      updatedAt: new Date('2025-01-02'),
    };
  }
  
  getShipment(id: ShipmentId): Shipment {
    return {
      id,
      orderId: createOrderId('order-123'),
      trackingNumber: 'TRACK123456',
      carrier: 'FedEx',
      status: ShipmentStatus.SHIPPED,
      shippedAt: new Date('2025-01-03'),
      createdAt: new Date('2025-01-03'),
      updatedAt: new Date('2025-01-04'),
    };
  }
  
  getInvoice(id: InvoiceId): Invoice {
    return {
      id,
      orderId: createOrderId('order-123'),
      invoiceNumber: 'INV-2025-001',
      amount: 3000,
      taxAmount: 300,
      totalAmount: 3300,
      status: InvoiceStatus.ISSUED,
      issuedAt: new Date('2025-01-05'),
      dueAt: new Date('2025-02-05'),
      createdAt: new Date('2025-01-05'),
      updatedAt: new Date('2025-01-06'),
    };
  }
}

/**
 * 注文処理関数（型安全）
 */
function processOrder(order: Order): void {
  console.log(`Processing order: ${order.id}`);
  console.log(`Total amount: ¥${order.totalAmount}`);
  console.log(`Status: ${order.status}`);
  // 注文の処理
}

/**
 * 配送処理関数（型安全）
 */
function processShipment(shipment: Shipment): void {
  console.log(`Processing shipment: ${shipment.id}`);
  console.log(`Tracking number: ${shipment.trackingNumber}`);
  console.log(`Carrier: ${shipment.carrier}`);
  console.log(`Status: ${shipment.status}`);
  // 配送の処理
}

/**
 * 請求書処理関数（型安全）
 */
function processInvoice(invoice: Invoice): void {
  console.log(`Processing invoice: ${invoice.invoiceNumber}`);
  console.log(`Total amount: ¥${invoice.totalAmount}`);
  console.log(`Due date: ${invoice.dueAt}`);
  // 請求書の処理
}

// 使用例（型安全になった）
function example() {
  const productService = new ProductService();
  const orderService = new OrderService();
  
  const productId = createProductId('1');
  const categoryId = createCategoryId('electronics');
  
  const product = productService.getProduct(productId);
  const category = productService.getCategory(categoryId);
  
  // OK: 正しい型を渡している
  productService.displayProduct(product);
  productService.displayCategory(category);
  
  // エラー: 型が一致しないのでコンパイルエラー
  // productService.displayProduct(category);
  // productService.displayCategory(product);
  
  const orderId = createOrderId('order-123');
  const shipmentId = createShipmentId('shipment-456');
  const invoiceId = createInvoiceId('invoice-789');
  
  const order = orderService.getOrder(orderId);
  const shipment = orderService.getShipment(shipmentId);
  const invoice = orderService.getInvoice(invoiceId);
  
  // OK: 正しい型を渡している
  processOrder(order);
  processShipment(shipment);
  processInvoice(invoice);
  
  // エラー: 型が一致しないのでコンパイルエラー
  // processOrder(shipment);
  // processShipment(order);
  // processInvoice(order);
}
```

## 改善のポイント

### 1. Branded Type による型の区別

```typescript
type Brand<K, T> = K & { __brand: T };
type ProductId = Brand<string, 'ProductId'>;
type CategoryId = Brand<string, 'CategoryId'>;
```

- 実行時は通常のstringだが、型システム上は区別される
- 異なる概念のIDを間違えて使用するとコンパイルエラー
- パフォーマンスへの影響なし

### 2. 概念ごとの明確な型定義

```typescript
interface Product {
  id: ProductId;
  name: string;
  price: number;
  stock: number;
  categoryId: CategoryId;
}

interface Category {
  id: CategoryId;
  name: string;
  description: string;
  parentCategoryId?: CategoryId;
}
```

- 商品とカテゴリーは別の型
- それぞれ固有のプロパティを持つ
- ドメインモデルが明確に

### 3. 列挙型によるステータスの管理

```typescript
enum OrderStatus {
  PENDING = 'PENDING',
  CONFIRMED = 'CONFIRMED',
  SHIPPED = 'SHIPPED',
  DELIVERED = 'DELIVERED',
  CANCELLED = 'CANCELLED',
}
```

- 文字列よりも型安全
- IDEの補完が効く
- タイポを防げる

### 4. ファクトリー関数による Branded Type の生成

```typescript
function createProductId(id: string): ProductId {
  return id as ProductId;
}
```

- 型の変換を一箇所に集約
- バリデーションを追加しやすい

## さらなる改善案

### バリデーション付きファクトリー

```typescript
class InvalidIdError extends Error {
  constructor(id: string, type: string) {
    super(`Invalid ${type} ID: ${id}`);
    this.name = 'InvalidIdError';
  }
}

function createProductId(id: string): ProductId {
  if (!id || id.trim() === '') {
    throw new InvalidIdError(id, 'Product');
  }
  
  if (!id.startsWith('product-')) {
    throw new InvalidIdError(id, 'Product');
  }
  
  return id as ProductId;
}
```

### Opaque Type（より厳密な名目的型付け）

```typescript
/**
 * より厳密な Opaque Type
 */
declare const opaqueSymbol: unique symbol;

type Opaque<K, T> = K & { readonly [opaqueSymbol]: T };

type StrictProductId = Opaque<string, 'ProductId'>;
type StrictCategoryId = Opaque<string, 'CategoryId'>;

// as を使わずに型安全に変換
function toProductId(id: string): StrictProductId {
  // バリデーション
  if (!id.startsWith('product-')) {
    throw new Error('Invalid product ID');
  }
  return id as StrictProductId;
}
```

### ジェネリクスを使った共通処理

```typescript
/**
 * タイムスタンプを持つエンティティの共通インターフェース
 */
interface Timestamped {
  createdAt: Date;
  updatedAt: Date;
}

/**
 * ジェネリック関数で共通処理
 */
function formatTimestamp<T extends Timestamped>(entity: T): string {
  return `Created: ${entity.createdAt}, Updated: ${entity.updatedAt}`;
}

// 使用例
const order: Order = /* ... */;
const shipment: Shipment = /* ... */;

console.log(formatTimestamp(order));
console.log(formatTimestamp(shipment));
```

### リポジトリパターンでの活用

```typescript
/**
 * ジェネリックリポジトリ
 */
interface Repository<TEntity, TId> {
  findById(id: TId): Promise<TEntity | null>;
  save(entity: TEntity): Promise<void>;
  delete(id: TId): Promise<void>;
}

/**
 * 商品リポジトリ
 */
class ProductRepository implements Repository<Product, ProductId> {
  async findById(id: ProductId): Promise<Product | null> {
    // 実装
    return null;
  }
  
  async save(product: Product): Promise<void> {
    // 実装
  }
  
  async delete(id: ProductId): Promise<void> {
    // 実装
  }
}

// 使用例
const productRepo = new ProductRepository();
const productId = createProductId('product-1');
const product = await productRepo.findById(productId);

// エラー: CategoryIdは使えない
// const categoryId = createCategoryId('electronics');
// const product = await productRepo.findById(categoryId);
```

## 学んだこと

1. **構造が似ていても概念が違えば別の型に**
   - `IdAndName`のような汎用型は避ける
   - ドメインの概念を型で表現

2. **Branded Type の威力**
   - 実行時のオーバーヘッドなし
   - コンパイル時の型チェックで安全性向上
   - プリミティブ型に意味を持たせられる

3. **型安全性によるバグの早期発見**
   - 異なる概念のデータを間違えて使用するとコンパイルエラー
   - IDEの補完も適切に機能

4. **ドメイン駆動設計との親和性**
   - ユビキタス言語を型で表現
   - ビジネスロジックが明確に

## 型設計のチェックリスト

- [ ] 異なる概念に同じ型を使っていないか？
- [ ] IDに意味を持たせているか？（Branded Type）
- [ ] 列挙型を適切に使っているか？
- [ ] ドメインモデルが型で表現されているか？
- [ ] 型の変換を適切に管理しているか？
- [ ] ジェネリクスで共通処理を再利用しているか？
